<p>Here are some Python examples of how to actually implement generators as if Python did not provide syntactic sugar for them:</p>

<p><strong>As a Python generator:</strong></p>

<pre><code>from itertools import islice

def fib_gen():
    a, b = 1, 1
    while True:
        yield a
        a, b = b, a + b

assert [1, 1, 2, 3, 5] == list(islice(fib_gen(), 5))
</code></pre>

<p><strong>Using lexical closures instead of generators</strong></p>

<pre><code>def ftake(fnext, last):
    return [fnext() for _ in xrange(last)]

def fib_gen2():
    #funky scope due to python2.x workaround
    #for python 3.x use nonlocal
    def _():
        _.a, _.b = _.b, _.a + _.b
        return _.a
    _.a, _.b = 0, 1
    return _

assert [1,1,2,3,5] == ftake(fib_gen2(), 5)
</code></pre>

<p><strong>Using object closures instead of generators</strong> (because <a href="http://c2.com/cgi/wiki?ClosuresAndObjectsAreEquivalent" rel="noreferrer">ClosuresAndObjectsAreEquivalent</a>)</p>

<pre><code>class fib_gen3:
    def __init__(self):
        self.a, self.b = 1, 1

    def __call__(self):
        r = self.a
        self.a, self.b = self.b, self.a + self.b
        return r

assert [1,1,2,3,5] == ftake(fib_gen3(), 5)
</code></pre>
