<p><strong>TL;DR</strong></p>

<h1>Instead of this:</h1>

<pre><code>def square_list(n):
    the_list = []                         # Replace
    for x in range(n):
        y = x * x
        the_list.append(y)                # these
    return the_list                       # lines
</code></pre>

<h1>do this:</h1>

<pre><code>def square_yield(n):
    for x in range(n):
        y = x * x
        yield y                           # with this one.
</code></pre>

<p>Whenever you find yourself building a list from scratch, <code>yield</code> each piece instead. </p>

<p>This was my first "aha" moment with yield.</p>

<hr>

<p><code>yield</code> is a <a href="https://en.wikipedia.org/wiki/Syntactic_sugar" rel="noreferrer">sugary</a> way to say </p>

<blockquote>
  <p>build a series of stuff</p>
</blockquote>

<p>Same behavior:</p>

<pre><code>&gt;&gt;&gt; for square in square_list(4):
...     print(square)
...
0
1
4
9
&gt;&gt;&gt; for square in square_yield(4):
...     print(square)
...
0
1
4
9
</code></pre>

<p>Different behavior:</p>

<p>Yield is <strong>single-pass</strong>: you can only iterate through once. When a function has a yield in it we call it a <a href="https://stackoverflow.com/a/1756342/673991">generator function</a>. And an <a href="https://stackoverflow.com/a/9884501/673991">iterator</a> is what it returns. Those terms are revealing. We lose the convenience of a container, but gain the power of a series that's computed as needed, and arbitrarily long.</p>

<p>Yield is <strong>lazy</strong>, it puts off computation. A function with a yield in it <em>doesn't actually execute at all when you call it.</em> It returns an <a href="https://docs.python.org/3/reference/expressions.html#yieldexpr" rel="noreferrer">iterator object</a> that remembers where it left off. Each time you call <code>next()</code> on the iterator (this happens in a for-loop) execution inches forward to the next yield. <code>return</code> raises StopIteration and ends the series (this is the natural end of a for-loop).</p>

<p>Yield is <strong>versatile</strong>. Data doesn't have to be stored all together, it can be made available one at a time. It can be infinite.</p>

<pre><code>&gt;&gt;&gt; def squares_all_of_them():
...     x = 0
...     while True:
...         yield x * x
...         x += 1
...
&gt;&gt;&gt; squares = squares_all_of_them()
&gt;&gt;&gt; for _ in range(4):
...     print(next(squares))
...
0
1
4
9
</code></pre>

<hr>

<p>If you need <strong>multiple passes</strong> and the series isn't too long, just call <code>list()</code> on it:</p>

<pre><code>&gt;&gt;&gt; list(square_yield(4))
[0, 1, 4, 9]
</code></pre>

<hr>

<p>Brilliant choice of the word <code>yield</code> because <a href="https://www.google.com/search?q=yield+meaning" rel="noreferrer">both meanings</a> apply:</p>

<blockquote>
  <p><strong>yield</strong> &mdash; produce or provide (as in agriculture)</p>
</blockquote>

<p>...provide the next data in the series.</p>

<blockquote>
  <p><strong>yield</strong> &mdash; give way or relinquish (as in political power)</p>
</blockquote>

<p>...relinquish CPU execution until the iterator advances.</p>
