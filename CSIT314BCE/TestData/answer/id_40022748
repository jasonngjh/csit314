<p>In summary, the <code>yield</code> statement transforms your function into a factory that produces a special object called a <code>generator</code> which wraps around the body of your original function. When the <code>generator</code> is iterated, it executes your function  until it reaches the next <code>yield</code> then suspends execution and evaluates to the value passed to <code>yield</code>. It repeats this process on each iteration until the path of execution exits the function. For instance,</p>

<pre><code>def simple_generator():
    yield 'one'
    yield 'two'
    yield 'three'

for i in simple_generator():
    print i
</code></pre>

<p>simply outputs</p>

<pre><code>one
two
three
</code></pre>

<p>The power comes from using the generator with a loop that calculates a sequence, the generator executes the loop stopping each time to 'yield' the next result of the calculation, in this way it calculates a list on the fly, the benefit being the memory saved for especially large calculations</p>

<p>Say you wanted to create a your own <code>range</code> function that produces an iterable range of numbers, you could do it like so,</p>

<pre><code>def myRangeNaive(i):
    n = 0
    range = []
    while n &lt; i:
        range.append(n)
        n = n + 1
    return range
</code></pre>

<p>and use it like this;</p>

<pre><code>for i in myRangeNaive(10):
    print i
</code></pre>

<p>But this is inefficient because</p>

<ul>
<li>You create an array that you only use once (this wastes memory)</li>
<li>This code actually loops over that array twice! :(</li>
</ul>

<p>Luckily Guido and his team were generous enough to develop generators so we could just do this;</p>

<pre><code>def myRangeSmart(i):
    n = 0
    while n &lt; i:
       yield n
       n = n + 1
    return

for i in myRangeSmart(10):
    print i
</code></pre>

<p>Now upon each iteration a function on the generator called <code>next()</code> executes the function until it either reaches a 'yield' statement in which it stops and  'yields' the value or reaches the end of the function. In this case on the first call, <code>next()</code> executes up to the yield statement and yield 'n', on the next call it will execute the  increment statement, jump back to the 'while', evaluate it, and if true, it will stop and yield 'n' again, it will continue that way until the while condition returns false and the generator jumps to the end of the function.</p>
