<p>yield in python is in a way similar to the return statement, except for some differences. If multiple values have to be returned from a function, return statement will return all the values as a list and it has to be stored in the memory in the caller block. But what if we don't want to use extra memory? Instead, we want to get the value from the function when we need it. This is where yield comes in. Consider the following function :-</p>

<pre><code>def fun():
   yield 1
   yield 2
   yield 3
</code></pre>

<p>And the caller is :-</p>

<pre><code>def caller():
   print ('First value printing')
   print (fun())
   print ('Second value printing')
   print (fun())
   print ('Third value printing')
   print (fun())
</code></pre>

<p>The above code segment (caller function) when called, outputs :-</p>

<pre><code>First value printing
1
Second value printing
2
Third value printing
3
</code></pre>

<p>As can be seen from above, yield returns a value to its caller, but when the function is called again, it doesn't start from the first statement, but from the statement right after the yield. In the above example, "First value printing" was printed and the function was called. 1 was returned and printed. Then "Second value printing" was printed and again fun() was called. Instead of printing 1 (the first statement), it returned 2, i.e., the statement just after yield 1. The same process is repeated further.</p>
