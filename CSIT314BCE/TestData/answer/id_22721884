<p>I have read all of these before in the past, and they are all very informative. Some come very close to getting the simple explanation and then get complex or remain abstract, defeating the purpose and failing to show a very simple real world use. </p>

<p>Though combing through all the examples and explanations you get a good idea of what closures are and aren't via comments and code, I was still unsatisfied with a very simple illustration that helped me get a closures usefulness without getting so complex. My wife wants to learn coding and I figured I needed to be able to show here not only what, but why, and and how.</p>

<p>I am not sure a six year old will get this, but I think it might be a little closer to demonstrating a simple case in a real world way that might acually be useful and that is easily understandable.</p>

<p>One of the best (or closest to simplest) is the retelling of Morris' Closures for Dummies example.</p>

<p>Taking the "SayHi2Bob" concept just one step further demonstrates the two basic things you can glean from reading all the answers:</p>

<ol>
<li>Closures have access to the containing function's variables.</li>
<li>Closures persist in their own memory space (and thus are useful for all kinds of oop-y instantiation stuff)</li>
</ol>

<p>Proving and demonstrating this to myself, I made a little fiddle:</p>

<p><a href="http://jsfiddle.net/9ZMyr/2/">http://jsfiddle.net/9ZMyr/2/</a></p>

<pre><code>function sayHello(name) {
  var text = 'Hello ' + name; // Local variable
  console.log(text);
  var sayAlert = function () {
      alert(text);
  }
  return sayAlert;
}

sayHello(); 
/* This will write 'Hello undefined' to the console (in Chrome anyway), 
but will not alert though since it returns a function handle to nothing). 
Since no handle or reference is created, I imagine a good js engine would 
destroy/dispose of the internal sayAlert function once it completes. */

// Create a handle/reference/instance of sayHello() using the name 'Bob'
sayHelloBob = sayHello('Bob');
sayHelloBob();

// Create another handle or reference to sayHello with a different name
sayHelloGerry = sayHello('Gerry');
sayHelloGerry();

/* Now calling them again demonstrates that each handle or reference contains its own 
unique local variable memory space. They remain in memory 'forever' 
(or until your computer/browser explode) */
sayHelloBob();
sayHelloGerry();
</code></pre>

<p>This demonstrates both of the basic concepts you should get about closures. </p>

<p>In simple terms to explain the why this is useful, I have a base function to which I can make references or handles that contain unique data which persists within that memory reference. I don't have to rewrite the function for each time I want to say someone's name. I have encapsulated that routine and made it reusable.</p>

<p>To me this leads to at least the basic concepts of constructors, oop practices, singletons vs instantiated instances with their own data, etc. etc.</p>

<p>If you start a neophyte with this, then you can move on to more complex object property/member based calls, and hopefully the concepts carry.</p>
