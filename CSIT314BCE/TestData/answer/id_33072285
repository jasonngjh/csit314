<p>The best way is to explain these concepts incrementally:</p>

<p><strong>Variables</strong></p>

<pre><code>console.log(x);
// undefined
</code></pre>

<p>Here, <code>undefined</code> is JavaScript's way of saying "I have no idea what <code>x</code> means."</p>

<blockquote>
  <p>Variables are like tags.</p>
</blockquote>

<p>You can say, tag <code>x</code> points to value <code>42</code>:</p>

<pre><code>var x = 42;
console.log(x);
// 42
</code></pre>

<p>Now JavaScript knows what <code>x</code> means.</p>

<blockquote>
  <p>You can also re-assign a variable.</p>
</blockquote>

<p>Make tag <code>x</code> point to a different value:</p>

<pre><code>x = 43;
console.log(x);
// 43
</code></pre>

<p>Now <code>x</code> means something else.</p>

<p><strong>Scope</strong></p>

<blockquote>
  <p>When you make a function, the function has its own "box" for variables.</p>
</blockquote>

<pre><code>function A() {
  var x = 42;
}

console.log(x);

// undefined
</code></pre>

<p>From outside the box, you cannot see what's inside the box.</p>

<p>But from inside the box, you can see what's outside that box:</p>

<pre><code>var x = 42;

function A() {
  console.log(x);
}

// 42
</code></pre>

<blockquote>
  <p>Inside function <code>A</code>, you have "scope access" to <code>x</code>.</p>
</blockquote>

<p>Now if you have two boxes side-by-side:</p>

<pre><code>function A() {
  var x = 42;
}

function B() {
  console.log(x);
}

// undefined
</code></pre>

<blockquote>
  <p>Inside function <code>B</code>, you have no access to variables inside function <code>A</code>.</p>
</blockquote>

<p>But if you put define function <code>B</code> inside function <code>A</code>:</p>

<pre><code>function A() {

  var x = 42;

  function B() {
    console.log(x);
  }

}

// 42
</code></pre>

<p>You now have "scope access".</p>

<p><strong>Functions</strong></p>

<p>In JavaScript, you run a function by calling it:</p>

<pre><code>function A() {
  console.log(42);
}
</code></pre>

<p>Like this:</p>

<pre><code>A();

// 42
</code></pre>

<p><strong>Functions as Values</strong></p>

<p>In JavaScript, you can point a tag to a function, just like pointing to a number:</p>

<pre><code>var a = function() {
  console.log(42);
};
</code></pre>

<blockquote>
  <p>Variable <code>a</code> now means a function, you can run it.</p>
</blockquote>

<pre><code>a();
// 42
</code></pre>

<p>You can also pass this variable around:</p>

<pre><code>setTimeout(a, 1000);
</code></pre>

<p>In a second (1000 milliseconds), the function <code>a</code> points to is called:</p>

<pre><code>// 42
</code></pre>

<p><strong>Closure Scope</strong></p>

<p>Now when you define functions, those functions have access to their outer scopes.</p>

<p>When you pass functions around as values, it would be troublesome if that access is lost.</p>

<blockquote>
  <p>In JavaScript, functions keep their access to outer scope variables.
  Even when they are passed around to be run somewhere else.</p>
</blockquote>

<pre><code>var a = function() {

  var text = 'Hello!'

  var b = function() {
    console.log(text);
    // inside function `b`, you have access to `text`
  };

  // but you want to run `b` later, rather than right away
  setTimeout(b, 1000);

}
</code></pre>

<p>What happens now?</p>

<pre><code>// 'Hello!'
</code></pre>

<p>Or consider this:</p>

<pre><code>var c;

var a = function() {

  var text = 'Hello!'

  var b = function() {
    console.log(text);
    // inside function `b`, you have access to `text`
  };

  c = b;

}

// now we are out side of function `a`
// call `a` so the code inside `a` runs
a(); 

// now `c` has a value that is a function
// because what happened when `a` ran

// when you run `c`
c();

// 'Hello!'
</code></pre>

<blockquote>
  <p>You can still access variables in the closure scope.</p>
</blockquote>

<p>Even though <code>a</code> has finished running, and now you are running <code>c</code> outside of <code>a</code>.</p>

<p>What just happened here is called '<strong><em>closure</em></strong>' in JavaScript.</p>
