<p>First of all, try the standard way:</p>

<pre><code>git reset HEAD --hard # To remove all not committed changes!
git clean -fd         # To remove all untracked (non-git) files and folders!
</code></pre>

<p><sup><strong>Warning</strong>: Above commands can results in data/files loss only if you don't have them committed! If you're not sure, make the backup first of your whole repository folder.</sup></p>

<p>Then pull it again.</p>

<p>If above won't help and you don't care about your untracked files/directories (make the backup first just in case), try the following simple steps:</p>

<pre><code>cd your_git_repo  # where 'your_git_repo' is your git repository folder
rm -rfv *         # WARNING: only run inside your git repository!
git pull          # pull the sources again
</code></pre>

<p>This will REMOVE all git files (excempt <code>.git/</code> dir, where you have all commits) and pull it again.</p>

<hr>

<p>Why <code>git reset HEAD --hard</code> could fail in some cases?</p>

<ol>
<li><p>Custom rules in <code>.gitattributes file</code></p>

<p>Having <code>eol=lf</code> rule in .gitattributes could cause git to modify some file changes by converting CRLF line-endings into LF in some text files.</p>

<p>If that's the case, you've to commit these CRLF/LF changes (by reviewing them in <code>git status</code>), or try: <code>git config core.autcrlf false</code> to temporary ignore them.</p></li>
<li><p>File system incompability</p>

<p>When you're using file-system which doesn't support permission attributes.
In example you have two repositories, one on Linux/Mac (<code>ext3</code>/<code>hfs+</code>) and another one on FAT32/NTFS based file-system.</p>

<p>As you notice, there are two different kind of file systems, so the one which doesn't support Unix permissions basically can't reset file permissions on system which doesn't support that kind of permissions, so no matter how <code>--hard</code> you try, git always detect some "changes".</p></li>
</ol>
