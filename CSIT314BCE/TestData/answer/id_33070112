<p>An official answer would be from</p>

<ol>
<li><a href="https://software.intel.com/en-us/articles/avoiding-the-cost-of-branch-misprediction" rel="noreferrer">Intel - Avoiding the Cost of Branch Misprediction</a></li>
<li><a href="https://software.intel.com/en-us/articles/branch-and-loop-reorganization-to-prevent-mispredicts" rel="noreferrer">Intel - Branch and Loop Reorganization to Prevent Mispredicts</a></li>
<li><a href="https://scholar.google.com/scholar?q=branch%20prediction%20computer%20architecture&amp;hl=da&amp;as_sdt=0&amp;as_vis=1&amp;oi=scholart" rel="noreferrer">Scientific papers - branch prediction computer architecture</a></li>
<li>Books: J.L. Hennessy, D.A. Patterson: Computer architecture: a quantitative approach</li>
<li>Articles in scientific publications: T.Y. Yeh, Y.N. Patt made a lot of these on branch predictions.</li>
</ol>

<p>You can also see from this lovely <a href="https://en.wikipedia.org/wiki/Branch_predictor#/media/File:Branch_prediction_2bit_saturating_counter-dia.svg" rel="noreferrer">diagram</a> why the branch predictor gets confused.</p>

<p><a href="https://i.stack.imgur.com/pBMV2.png" rel="noreferrer"><img src="https://i.stack.imgur.com/pBMV2.png" alt="2-bit state diagram"></a></p>

<p>Each element in the original code is a random value</p>

<pre><code>data[c] = std::rand() % 256;
</code></pre>

<p>so the predictor will change sides as the <code>std::rand()</code> blow.</p>

<p>On the other hand, once it's sorted, the predictor will first move into a state of strongly not taken and when the values change to the high value the predictor will in three runs through change all the way from strongly not taken to strongly taken.</p>

<hr>
