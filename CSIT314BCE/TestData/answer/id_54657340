<p>In simple terms, if you were about to hop onto a plane without any Internet connection...before departing you could just do <code>git fetch origin &lt;master&gt;</code>. It would fetch all the changes into your computer, but keep it separate from your local development/workspace.</p>

<p>On the plane, you could make changes to your local workspace and then merge it with what you've fetched and resolve potential merge conflicts all without a connection to the Internet. And unless someone had made <em>new</em> conflicting changes to the remote repository then once you arrive at the destination you would do <code>git push origin &lt;branch&gt;</code> and go get your coffee.</p>

<hr>

<p>From this awesome <a href="https://www.atlassian.com/git/tutorials/syncing/git-fetch" rel="noreferrer">Atlassian tutorial</a>:</p>

<blockquote>
  <p>The <code>git fetch</code> command downloads commits, files, and refs from a
  remote repository into your local repository.</p>
  
  <p>Fetching is what you do when you want to see what everybody <em>else</em> has
  been working on. It’s similar to SVN update in that it lets you see
  how the central history has progressed, but it doesn’t force you to
  actually merge the changes into your repository. Git <strong>isolates
  fetched content as a from existing local content</strong>, it has absolutely
  <strong>no effect on your local development work</strong>. Fetched content has to be explicitly checked out using the <code>git checkout</code> command. This makes
  fetching a safe way to review commits before integrating them with
  your local repository.</p>
  
  <p>When downloading content from a remote repository, <code>git pull</code> and <code>git fetch</code> commands are available to accomplish the task. You can consider
  <code>git fetch</code> the 'safe' version of the two commands. It will download
  the remote content, but not update your local repository's working state,
  leaving your current work intact. <code>git pull</code> is the more aggressive
  alternative, it will download the remote content for the active local
  branch and immediately execute <code>git merge</code> to create a merge commit
  for the new remote content. If you have pending changes in progress
  this will cause conflicts and kickoff the merge conflict resolution
  flow.</p>
</blockquote>

<hr>

<p>With <code>git pull</code>:</p>

<ul>
<li>You don't get any isolation.</li>
<li>It affects your local development.</li>
<li>It doesn't need to be explicitly checked out. Because it implicitly does a <code>git merge</code>.</li>
<li>It's basically NOT safe. It's aggressive.</li>
<li>Unlike <code>git fetch</code> where it only affects your <code>.git/refs/remotes</code>, git pull will affect both your <code>.git/refs/remotes</code> <strong>and</strong> <code>.git/refs/heads/</code></li>
</ul>

<hr>

<h3>Hmmm...so if I'm not updating the working copy with <code>git fetch</code>, then where am I making changes? Where does Git fetch store the new commits?</h3>

<p>Great question. It puts it somewhere isolated from your working copy. But again where? Let's find out.</p>

<p>In your project directory (i.e., where you do your <code>git</code> commands) do:</p>

<ol>
<li><p><code>ls</code>. This will show the files &amp; directories. Nothing cool, I know.</p></li>
<li><p>Now do <code>ls -a</code>. This will show <a href="https://unix.stackexchange.com/questions/21778/whats-so-special-about-directories-whose-names-begin-with-a-dot">dot files</a>, i.e., files beginning with <code>.</code> You will then be able to see a directory named: <code>.git</code>.</p></li>
<li>Do <code>cd .git</code>. This will obviously change your directory.</li>
<li>Now comes the fun part; do <code>ls</code>. You will see a list of directories. We're looking for <code>refs</code>. Do <code>cd refs</code>.</li>
<li>It's interesting to see what's inside all directories, but let's focus on two of them. <code>heads</code> and <code>remotes</code>. Use <code>cd</code> to check inside them too.</li>
<li><em>Any</em> <code>git fetch</code> that you do will update items in the <code>/.git/refs/remotes</code> directory. It won't update anything in the <code>/.git/refs/heads</code> directory.</li>
<li><em>Any</em> <code>git pull</code> will first do the <code>git fetch</code>, update items in the <code>/.git/refs/remotes</code> directory, then merge with your local and then change the head inside the <code>/.git/refs/heads</code> directory.</li>
</ol>

<hr>

<p>A very good related answer can also be found in <em><a href="https://stackoverflow.com/questions/27554859/where-does-git-fetch-place-itself/27555444#27555444">Where does 'git fetch' place itself?</a></em>.</p>

<p>Also, look for "Slash notation" from the <a href="http://www.guyroutledge.co.uk/blog/git-branch-naming-conventions/" rel="noreferrer">Git branch naming conventions</a> post. It helps you better understand how Git places things in different directories.</p>

<hr>

<h2>To see the actual difference</h2>

<p>Just do: </p>

<pre><code>git fetch origin master
git checkout master
</code></pre>

<p>If the remote master was updated you'll get a message like this: </p>

<pre><code>Your branch is behind 'origin/master' by 2 commits, and can be fast-forwarded.
  (use "git pull" to update your local branch)
</code></pre>

<p>If you didn't <code>fetch</code> and just did <code>git checkout master</code> then your local git wouldn't know that there are 2 commits added. And it would just say: </p>

<pre><code>Already on 'master'
Your branch is up to date with 'origin/master'.
</code></pre>

<p>But that's outdated and incorrect. It's because git will give you feedback solely based on what it knows. It's oblivious to new commits that it hasn't pulled down yet...</p>

<hr>

<h2>Is there any way to see the new changes made in remote while working on the branch locally?</h2>

<p>Some IDEs (e.g. Xcode) are super smart and use the result of a <code>git fetch</code> and can annotate the lines of code that have been changed in remote branch of your current working branch. If that line has been changed by both local changes and remote branch, then that line gets annotated with red. This isn't a merge conflict. It's a <em>potential</em> merge conflict. It's a headsup that you can use to resolve the future merge conflict before doing <code>git pull</code> from the remote branch. </p>

<p><a href="https://i.stack.imgur.com/OEl72.png" rel="noreferrer"><img src="https://i.stack.imgur.com/OEl72.png" alt="enter image description here"></a></p>

<hr>

<h2>Fun tip:</h2>

<p>If you fetched a remote branch e.g. did: </p>

<pre><code>git fetch origin feature/123
</code></pre>

<p>Then this would go into your remotes directory. It's still not available to your local directory. However, it simplifies your checkout to that remote branch by DWIM (Do what I mean):</p>

<pre><code>git checkout feature/123
</code></pre>

<p>you no longer need to do: </p>

<pre><code>git checkout -b feature/123 origin/feature/123
</code></pre>

<p>For more on that read <a href="https://stackoverflow.com/a/56464547/5175709">here</a></p>
