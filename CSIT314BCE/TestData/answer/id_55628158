<p><a href="https://stackoverflow.com/users/23283/jaredpar">@JaredPar</a> (a developer on the C# compiler and prolific SO user!) wrote a <a href="http://blog.paranoidcoding.com/2019/04/08/string-vs-String-is-not-about-style.html" rel="noreferrer">great blog post</a> on this issue. I think it is worth sharing here. It is a nice perspective on our subject.</p>

<blockquote>
  <h1><code>string</code> vs. <code>String</code> is not a style debate</h1>
  
  <p>[...]</p>
  
  <p>The keyword <code>string</code> has concrete meaning in C#. It is the type <code>System.String</code> which exists in the core runtime assembly. The runtime intrinsictly understands this type and provides the capabilities developers expect for strings in .NET. Its presence is so critical to C# that if that type doesn’t exist the compiler will exit before attempting to even parse a line of code. Hence <code>string</code> has a precise, unambiguous meaning in C# code.</p>
  
  <p>The identifier <code>String</code> though has no concrete meaning in C#. It is an identifier that goes through all the name lookup rules as <code>Widget</code>, <code>Student</code>, etc … It could bind to string or it could bind to a type in another assembly entirely whose purposes may be entirely different than <code>string</code>. Worse it could be defined in a way such that code like <code>String s = "hello"</code>; continued to compile.</p>

<pre><code>class TricksterString { 
  void Example() {
    String s = "Hello World"; // Okay but probably not what you expect.
  }
}

class String {
  public static implicit operator String(string s) =&gt; null;
}
</code></pre>
  
  <p>The actual meaning of <code>String</code> will always depend on name resolution.
  That means it depends on all the source files in the project and all
  the types defined in all the referenced assemblies. In short it
  requires quite a bit of context to <em>know</em> what it means.</p>
  
  <p>True that in the vast majority of cases <code>String</code> and <code>string</code> will bind to
  the same type. But using <code>String</code> still means developers are leaving
  their program up to interpretation in places where there is only one
  correct answer. When <code>String</code> does bind to the wrong type it can leave
  developers debugging for hours, filing bugs on the compiler team and
  generally wasting time that could’ve been saved by using <code>string</code>.</p>
  
  <p>Another way to visualize the difference is with this sample:</p>

<pre><code>string s1 = 42; // Errors 100% of the time  
String s2 = 42; // Might error, might not, depends on the code
</code></pre>
  
  <p>Many will argue that while this is information technically accurate using <code>String</code> is still fine because it’s exceedingly rare that a code base would define a type of this name. Or that when <code>String</code> is defined it’s a sign of a bad code base.</p>
  
  <p>[...]</p>
  
  <p>You’ll see that <code>String</code> is defined for a number of completely valid purposes: reflection helpers, serialization libraries, lexers, protocols, etc … For any of these libraries <code>String</code> vs. <code>string</code> has real consequences depending on where the code is used.</p>
  
  <p>So remember when you see the <code>String</code> vs. <code>string</code> debate this is about semantics, not style. Choosing string gives crisp meaning to your code base. Choosing <code>String</code> isn’t wrong but it’s leaving the door open for surprises in the future.</p>
</blockquote>

<p>Note: I copy/pasted most of the blog post for archive reason. I ignore some parts, so I recommend to skip and to read the <a href="http://blog.paranoidcoding.com/2019/04/08/string-vs-String-is-not-about-style.html" rel="noreferrer">blog post</a> if you can.</p>
