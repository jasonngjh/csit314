<p>Here's a script that does this process - I've only used it once, but worked fine for me ;-) </p>

<p>It reverts to the commit by basically making your repo look like it did at the time of that commit, and it does this in a very simple way - by tarring up the folder as it was then, then untarring that on top of the repo, after removing all other files!</p>

<p>So this should work fine with a public/shared repo, and will result in a branch that you can do a PR with. Note that since it wipes out all other files in the folder, you should do this on a freshly checked out copy of the repo (to avoid removing editor files, git ignored files, etc)</p>

<p>I came up with this when trying to revert to a commit that had merged commits, and was like 50 commits behind master. In hindsight, this could've been done by simply moving folders around, and not tarring things, but worked for my purposes and will probably work fine for most use cases.</p>

<h3>git_revert_to_commit.sh</h3>

<pre><code>#!/usr/bin/env bash
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &amp;&amp; pwd )"; PATH="$DIR:$PATH"

function show_help()
{
  ME=$(basename "$0")
  IT=$(cat &lt;&lt;EOF

  Reverts to a git commit by making your repo look exactly like
  it did at the time of that commit.

  It does this by 
  - deleting all files in the local repo that weren't in git 
  at the time of the commit, 
  - reverting all other files

  The catch is any git ignored files will be removed too. So the
  safest way to run this is in a fresh clone of your repo, in
  a folder you don't normally have IDE settings files, etc.

  usage: $ME sha_of_commit
EOF
)
  echo "$IT"
  echo
  exit
}

if [ -z "$1" ]
then
  show_help
fi
if [ "$1" == "help" ] || [ "$1" == '?' ] || [ "$1" == "--help" ] || [ "$1" == "h" ]; then
  show_help
fi

if [[ `git status --porcelain` ]]; then
  echo "There are unresolved changes in this branch. Please resolve and try again!"
  exit 1
fi

COMMIT=$1
PWD=`pwd`
REVERT_BRANCH="revert_to_commit_$COMMIT"
TAR_FILE="/tmp/somefile.tar"
GIT_BACKUP='/tmp/deletemegit'

if [ ! -d "$PWD/.git" ]
then
  echo "Error: This doesnt appear to be a git repo!"
  exit 1
fi

if ! git cat-file -e $COMMIT^{commit}; then
  echo
  echo "$COMMIT does not exist! Please specify a valid SHA, and try again!"
  exit 1
fi

echo "About to create a branch, which reverts to commit $COMMIT."
echo "New branch: $REVERT_BRANCH"
echo
read -n 1 -s -r -p "Press any key to continue, CTRL+C to abort"

echo
git checkout "$COMMIT" &amp;&gt; /dev/null
rm -f "$TAR_FILE"
find . -print0 | tar -cf "$TAR_FILE" --null -T -

git branch -D "$REVERT_BRANCH" &amp;&gt; /dev/null
git checkout -b "$REVERT_BRANCH" master &amp;&gt; /dev/null

# save the git folder
rm -fr "$GIT_BACKUP"
mv .git "$GIT_BACKUP"

# remove everything else
rm -fr * &amp;&gt; /dev/null
rm -fr .* &amp;&gt; /dev/null

# restore files from commit
tar xf "$TAR_FILE" -C "$PWD"
rm -fr .git

# put git folder back
mv "$GIT_BACKUP" .git

# get rid of tmp tar file
rm "$TAR_FILE"

git status
echo
echo "Success - Commit reverted in new branch, $REVERT_BRANCH"
echo "Now just do a PR with this branch against master, and you're good!"
</code></pre>
