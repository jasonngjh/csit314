<p>Frequently used Boolean operations in C++ produce many branches in the compiled program. If these branches are inside loops and are hard to predict they can slow down execution significantly. Boolean variables are stored as 8-bit integers with the value <code>0</code> for <code>false</code> and <code>1</code> for <code>true</code>.</p>

<p>Boolean variables are overdetermined in the sense that all operators that have Boolean variables as input check if the inputs have any other value than <code>0</code> or <code>1</code>, but operators that have Booleans as output can produce no other value than <code>0</code> or <code>1</code>. This makes operations with Boolean variables as input less efficient than necessary.
Consider example:</p>

<pre><code>bool a, b, c, d;
c = a &amp;&amp; b;
d = a || b;
</code></pre>

<p>This is typically implemented by the compiler in the following way:</p>

<pre><code>bool a, b, c, d;
if (a != 0) {
    if (b != 0) {
        c = 1;
    }
    else {
        goto CFALSE;
    }
}
else {
    CFALSE:
    c = 0;
}
if (a == 0) {
    if (b == 0) {
        d = 0;
    }
    else {
        goto DTRUE;
    }
}
else {
    DTRUE:
    d = 1;
}
</code></pre>

<p>This code is far from optimal. The branches may take a long time in case of mispredictions. The Boolean operations can be made much more efficient if it is known with certainty that the operands have no other values than <code>0</code> and <code>1</code>. The reason why the compiler does not make such an assumption is that the variables might have other values if they are uninitialized or come from unknown sources. The above code can be optimized if <code>a</code> and <code>b</code> has been initialized to valid values or if they come from operators that produce Boolean output. The optimized code looks like this:</p>

<pre><code>char a = 0, b = 1, c, d;
c = a &amp; b;
d = a | b;
</code></pre>

<p><code>char</code> is used instead of <code>bool</code> in order to make it possible to use the bitwise operators (<code>&amp;</code> and <code>|</code>) instead of the Boolean operators (<code>&amp;&amp;</code> and <code>||</code>). The bitwise operators are single instructions that take only one clock cycle. The OR operator (<code>|</code>) works even if <code>a</code> and <code>b</code> have other values than <code>0</code> or <code>1</code>. The AND operator (<code>&amp;</code>) and the EXCLUSIVE OR operator (<code>^</code>) may give inconsistent results if the operands have other values than <code>0</code> and <code>1</code>.</p>

<p><code>~</code> can not be used for NOT. Instead, you can make a Boolean NOT on a variable which is known to be <code>0</code> or <code>1</code> by XOR'ing it with <code>1</code>:</p>

<pre><code>bool a, b;
b = !a;
</code></pre>

<p>can be optimized to:</p>

<pre><code>char a = 0, b;
b = a ^ 1;
</code></pre>

<p><code>a &amp;&amp; b</code> cannot be replaced with <code>a &amp; b</code> if <code>b</code> is an expression that should not be evaluated if <code>a</code> is <code>false</code> ( <code>&amp;&amp;</code> will not evaluate <code>b</code>, <code>&amp;</code> will). Likewise, <code>a || b</code> can not be replaced with <code>a | b</code> if <code>b</code> is an expression that should not be evaluated if <code>a</code> is <code>true</code>.</p>

<p>Using bitwise operators is more advantageous if the operands are variables than if the operands are comparisons:</p>

<pre><code>bool a; double x, y, z;
a = x &gt; y &amp;&amp; z &lt; 5.0;
</code></pre>

<p>is optimal in most cases (unless you expect the <code>&amp;&amp;</code> expression to generate many branch mispredictions).</p>
