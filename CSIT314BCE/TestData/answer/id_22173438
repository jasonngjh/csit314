<p>Here's the rundown on the standard forms that create functions: <em>(Originally written for another question, but adapted after being moved into the canonical question.)</em></p>

<p>Terms:</p>

<ul>
<li><strong>ES5</strong>: <a href="http://ecma-international.org/ecma-262/5.1/" rel="noreferrer">ECMAScript 5th edition</a>, 2009</li>
<li><strong>ES2015</strong>: <a href="http://www.ecma-international.org/ecma-262/6.0/index.html" rel="noreferrer">ECMAScript 2015</a> (also known as "ES6")</li>
</ul>

<p>The quick list:</p>

<ul>
<li><p>Function Declaration</p></li>
<li><p>"Anonymous" <code>function</code> Expression <em>(which despite the term, sometimes create functions with names)</em></p></li>
<li><p>Named <code>function</code> Expression</p></li>
<li><p>Accessor Function Initializer (ES5+)</p></li>
<li><p>Arrow Function Expression (ES2015+) <em>(which, like anonymous function expressions, don't involve an explicit name, and yet can create functions with names)</em></p></li>
<li><p>Method Declaration in Object Initializer (ES2015+)</p></li>
<li><p>Constructor and Method Declarations in <code>class</code> (ES2015+)</p></li>
</ul>

<h3>Function Declaration</h3>

<p>The first form is a <em>function declaration</em>, which looks like this:</p>

<pre><code>function x() {
    console.log('x');
}
</code></pre>

<p>A function declaration is a <em>declaration</em>; it's not a statement or expression. As such, you don't follow it with a <code>;</code> (although doing so is harmless).</p>

<p>A function declaration is processed when execution enters the context in which it appears, <strong>before</strong> any step-by-step code is executed. The function it creates is given a proper name (<code>x</code> in the example above), and that name is put in the scope in which the declaration appears.</p>

<p>Because it's processed before any step-by-step code in the same context, you can do things like this:</p>

<pre><code>x(); // Works even though it's above the declaration
function x() {
    console.log('x');
}
</code></pre>

<p>Until ES2015, the spec didn't cover what a JavaScript engine should do if you put a function declaration inside a control structure like <code>try</code>, <code>if</code>, <code>switch</code>, <code>while</code>, etc., like this:</p>

<pre><code>if (someCondition) {
    function foo() {    // &lt;===== HERE THERE
    }                   // &lt;===== BE DRAGONS
}
</code></pre>

<p>And since they're processed <em>before</em> step-by-step code is run, it's tricky to know what to do when they're in a control structure.</p>

<p>Although doing this wasn't <em>specified</em> until ES2015, it was an <em>allowable extension</em> to support function declarations in blocks. Unfortunately (and inevitably), different engines did different things.</p>

<p>As of ES2015, the specification says what to do. In fact, it gives three separate things to do:</p>

<ol>
<li>If in loose mode <em>not</em> on a web browser, the JavaScript engine is supposed to do one thing</li>
<li>If in loose mode on a web browser, the JavaScript engine is supposed to do something else</li>
<li>If in <em>strict</em> mode (browser or not), the JavaScript engine is supposed to do yet another thing</li>
</ol>

<p>The rules for the loose modes are tricky, but in <em>strict</em> mode, function declarations in blocks are easy: They're local to the block (they have <em>block scope</em>, which is also new in ES2015), and they're hoisted to the top of the block. So:</p>

<pre><code>"use strict";
if (someCondition) {
    foo();               // Works just fine
    function foo() {
    }
}
console.log(typeof foo); // "undefined" (`foo` is not in scope here
                         // because it's not in the same block)
</code></pre>

<h3>"Anonymous" <code>function</code> Expression</h3>

<p>The second common form is called an <em>anonymous function expression</em>:</p>

<pre><code>var y = function () {
    console.log('y');
};
</code></pre>

<p>Like all expressions, it's evaluated when it's reached in the step-by-step execution of the code.</p>

<p>In ES5, the function this creates has no name (it's anonymous). In ES2015, the function is assigned a name if possible by inferring it from context. In the example above, the name would be <code>y</code>. Something similar is done when the function is the value of a property initializer. (For details on when this happens and the rules, search for <code>SetFunctionName</code> in the <a href="https://tc39.github.io/ecma262/" rel="noreferrer">the specification</a>&nbsp;&mdash; it appears <em>all over</em> the place.)</p>

<h3>Named <code>function</code> Expression</h3>

<p>The third form is a <em>named function expression</em> ("NFE"):</p>

<pre><code>var z = function w() {
    console.log('zw')
};
</code></pre>

<p>The function this creates has a proper name (<code>w</code> in this case). Like all expressions, this is evaluated when it's reached in the step-by-step execution of the code. The name of the function is <em>not</em> added to the scope in which the expression appears; the name <em>is</em> in scope within the function itself:</p>

<pre><code>var z = function w() {
    console.log(typeof w); // "function"
};
console.log(typeof w);     // "undefined"
</code></pre>

<p>Note that NFEs have frequently been a source of bugs for JavaScript implementations. IE8 and earlier, for instance, handle NFEs <a href="http://blog.niftysnippets.org/2010/09/double-take.html" rel="noreferrer">completely incorrectly</a>, creating two different functions at two different times. Early versions of Safari had issues as well. The good news is that current versions of browsers (IE9 and up, current Safari) don't have those issues any more. (But as of this writing, sadly, IE8 remains in widespread use, and so using NFEs with code for the web in general is still problematic.)</p>

<h3>Accessor Function Initializer (ES5+)</h3>

<p>Sometimes functions can sneak in largely unnoticed; that's the case with <em>accessor functions</em>. Here's an example:</p>

<pre><code>var obj = {
    value: 0,
    get f() {
        return this.value;
    },
    set f(v) {
        this.value = v;
    }
};
console.log(obj.f);         // 0
console.log(typeof obj.f);  // "number"
</code></pre>

<p>Note that when I used the function, I didn't use <code>()</code>! That's because it's an <em>accessor function</em> for a property. We get and set the property in the normal way, but behind the scenes, the function is called.</p>

<p>You can also create accessor functions with <code>Object.defineProperty</code>, <code>Object.defineProperties</code>, and the lesser-known second argument to <code>Object.create</code>.</p>

<h3>Arrow Function Expression (ES2015+)</h3>

<p>ES2015 brings us the <em>arrow function</em>. Here's one example:</p>

<pre><code>var a = [1, 2, 3];
var b = a.map(n =&gt; n * 2);
console.log(b.join(", ")); // 2, 4, 6
</code></pre>

<p>See that <code>n =&gt; n * 2</code> thing hiding in the <code>map()</code> call? That's a function.</p>

<p>A couple of things about arrow functions:</p>

<ol>
<li><p>They don't have their own <code>this</code>. Instead, they <em>close over</em> the <code>this</code> of the context where they're defined. (They also close over <code>arguments</code> and, where relevant, <code>super</code>.) This means that the <code>this</code> within them is the same as the <code>this</code> where they're created, and cannot be changed.</p></li>
<li><p>As you'll have noticed with the above, you don't use the keyword <code>function</code>; instead, you use <code>=&gt;</code>.</p></li>
</ol>

<p>The <code>n =&gt; n * 2</code> example above is one form of them. If you have multiple arguments to pass the function, you use parens:</p>

<pre><code>var a = [1, 2, 3];
var b = a.map((n, i) =&gt; n * i);
console.log(b.join(", ")); // 0, 2, 6
</code></pre>

<p>(Remember that <code>Array#map</code> passes the entry as the first argument, and the index as the second.)</p>

<p>In both cases, the body of the function is just an expression; the function's return value will automatically be the result of that expression (you don't use an explicit <code>return</code>).</p>

<p>If you're doing more than just a single expression, use <code>{}</code> and an explicit <code>return</code> (if you need to return a value), as normal:</p>

<pre><code>var a = [
  {first: "Joe", last: "Bloggs"},
  {first: "Albert", last: "Bloggs"},
  {first: "Mary", last: "Albright"}
];
a = a.sort((a, b) =&gt; {
  var rv = a.last.localeCompare(b.last);
  if (rv === 0) {
    rv = a.first.localeCompare(b.first);
  }
  return rv;
});
console.log(JSON.stringify(a));
</code></pre>

<p>The version without <code>{ ... }</code> is called an arrow function with an <em>expression body</em> or <em>concise body</em>. (Also: A <em>concise</em> arrow function.) The one with <code>{ ... }</code> defining the body is an arrow function with a <em>function body</em>. (Also: A <em>verbose</em> arrow function.)</p>

<h3>Method Declaration in Object Initializer (ES2015+)</h3>

<p>ES2015 allows a shorter form of declaring a property that references a function called a <em>method definition</em>; it looks like this:</p>

<pre><code>var o = {
    foo() {
    }
};
</code></pre>

<p>the almost-equivalent in ES5 and earlier would be:</p>

<pre><code>var o = {
    foo: function foo() {
    }
};
</code></pre>

<p>the difference (other than verbosity) is that a method can use <code>super</code>, but a function cannot. So for instance, if you had an object that defined (say) <code>valueOf</code> using method syntax, it could use <code>super.valueOf()</code> to get the value <code>Object.prototype.valueOf</code> would have returned (before presumably doing something else with it), whereas the ES5 version would have to do <code>Object.prototype.valueOf.call(this)</code> instead.</p>

<p>That also means that the method has a reference to the object it was defined on, so if that object is temporary (for instance, you're passing it into <code>Object.assign</code> as one of the source objects), method syntax <em>could</em> mean that the object is retained in memory when otherwise it could have been garbage collected (if the JavaScript engine doesn't detect that situation and handle it if none of the methods uses <code>super</code>).</p>

<h3>Constructor and Method Declarations in <code>class</code> (ES2015+)</h3>

<p>ES2015 brings us <code>class</code> syntax, including declared constructors and methods:</p>

<pre><code>class Person {
    constructor(firstName, lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

    getFullName() {
        return this.firstName + " " + this.lastName;
    }
}
</code></pre>

<p>There are two function declarations above: One for the constructor, which gets the name <code>Person</code>, and one for <code>getFullName</code>, which is a function assigned to <code>Person.prototype</code>.</p>
