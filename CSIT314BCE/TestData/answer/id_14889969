<p>As data is distributed between 0 and 255 when the array is sorted, around the first half of the iterations will not enter the <code>if</code>-statement (the <code>if</code> statement is shared below).</p>

<pre><code>if (data[c] &gt;= 128)
    sum += data[c];
</code></pre>

<p>The question is: What makes the above statement not execute in certain cases as in case of sorted data? Here comes the "branch predictor". A branch predictor is a digital circuit that tries to guess which way a branch (e.g. an <code>if-then-else</code> structure) will go before this is known for sure. The purpose of the branch predictor is to improve the flow in the instruction pipeline. Branch predictors play a critical role in achieving high effective performance!</p>

<p><strong>Let's do some bench marking to understand it better</strong></p>

<p>The performance of an <code>if</code>-statement depends on whether its condition has a predictable pattern. If the condition is always true or always false, the branch prediction logic in the processor will pick up the pattern. On the other hand, if the pattern is unpredictable, the <code>if</code>-statement will be much more expensive.</p>

<p>Let’s measure the performance of this loop with different conditions:</p>

<pre><code>for (int i = 0; i &lt; max; i++)
    if (condition)
        sum++;
</code></pre>

<p>Here are the timings of the loop with different true-false patterns:</p>

<pre><code>Condition                Pattern             Time (ms)
-------------------------------------------------------
(i &amp; 0×80000000) == 0    T repeated          322

(i &amp; 0xffffffff) == 0    F repeated          276

(i &amp; 1) == 0             TF alternating      760

(i &amp; 3) == 0             TFFFTFFF…           513

(i &amp; 2) == 0             TTFFTTFF…           1675

(i &amp; 4) == 0             TTTTFFFFTTTTFFFF…   1275

(i &amp; 8) == 0             8T 8F 8T 8F …       752

(i &amp; 16) == 0            16T 16F 16T 16F …   490
</code></pre>

<p>A “<strong>bad</strong>” true-false pattern can make an <code>if</code>-statement up to six times slower than a “<strong>good</strong>” pattern! Of course, which pattern is good and which is bad depends on the exact instructions generated by the compiler and on the specific processor.</p>

<p>So there is no doubt about the impact of branch prediction on performance!</p>
