<p>The above behavior is happening because of Branch prediction.</p>

<p>To understand branch prediction one must first understand <strong>Instruction Pipeline</strong>:</p>

<p>Any instruction is broken into a sequence of steps so that different steps can be executed concurrently in parallel. This technique is known as instruction pipeline and this is used to increase throughput in modern processors. To understand this better please see this <a href="https://en.wikipedia.org/wiki/Pipeline_(computing)#Concept_and_motivation" rel="noreferrer">example on Wikipedia</a>.</p>

<p>Generally, modern processors have quite long pipelines, but for ease let's consider these 4 steps only.</p>

<ol>  
  <li>IF -- Fetch the instruction from memory 
  <li>ID -- Decode the instruction
  <li>EX -- Execute the instruction 
  <li>WB -- Write back to CPU register
</ol>

<p><strong><em>4-stage pipeline in general for 2 instructions.</em></strong>
<img src="https://i.stack.imgur.com/PqBBR.png" alt="4-stage pipeline in general"></p>

<p>Moving back to the above question let's consider the following instructions:</p>

<pre><code>                        A) if (data[c] &gt;= 128)
                                /\
                               /  \
                              /    \
                        true /      \ false
                            /        \
                           /          \
                          /            \
                         /              \
              B) sum += data[c];          C) for loop or print().
</code></pre>

<p>Without branch prediction, the following would occur:</p>

<p>To execute instruction B or instruction C the processor will have to wait till the instruction A doesn't reach till EX stage in the pipeline, as the decision to go to instruction B or instruction C depends on the result of instruction A. So the pipeline will look like this.</p>

<p><strong><em>when if condition returns true:</em></strong>
<img src="https://i.stack.imgur.com/0H4gP.png" alt="enter image description here"></p>

<p><strong><em>When if condition returns false:</em></strong>
<img src="https://i.stack.imgur.com/APpca.png" alt="enter image description here"></p>

<p>As a result of waiting for the result of instruction A, the total CPU cycles spent in the above case (without branch prediction; for both true and false) is 7.</p>

<p><strong>So what is branch prediction?</strong></p>

<p>Branch predictor will try to guess which way a branch (an if-then-else structure) will go before this is known for sure. It will not wait for the instruction A to reach the EX stage of the pipeline, but it will guess the decision and go to that instruction (B or C in case of our example).</p>

<p><strong><em>In case of a correct guess, the pipeline looks something like this:</em></strong>
<img src="https://i.stack.imgur.com/ZYUbs.png" alt="enter image description here"></p>

<p>If it is later detected that the guess was wrong then the partially executed instructions are discarded and the pipeline starts over with the correct branch, incurring a delay. 
The time that is wasted in case of a branch misprediction is equal to the number of stages in the pipeline from the fetch stage to the execute stage. Modern microprocessors tend to have quite long pipelines so that the misprediction delay is between 10 and 20 clock cycles. The longer the pipeline the greater the need for a good <a href="https://en.wikipedia.org/wiki/Branch_predictor" rel="noreferrer">branch predictor</a>.</p>

<p>In the OP's code, the first time when the conditional, the branch predictor does not have any information to base up prediction, so the first time it will randomly choose the next instruction. Later in the for loop, it can base the prediction on the history. 
For an array sorted in ascending order, there are three possibilities:</p>

<ol>
<li> All the elements are less than 128
<li> All the elements are greater than 128
<li> Some starting new elements are less than 128 and later it become greater than 128
</ol>

<p>Let us assume that the predictor will always assume the true branch on the first run.</p>

<p>So in the first case, it will always take the true branch since historically all its predictions are correct.
In the 2nd case, initially it will predict wrong, but after a few iterations, it will predict correctly.
In the 3rd case, it will initially predict correctly till the elements are less than 128. After which it will fail for some time and the correct itself when it sees branch prediction failure in history. </p>

<p>In all these cases the failure will be too less in number and as a result, only a few times it will need to discard the partially executed instructions and start over with the correct branch, resulting in fewer CPU cycles. </p>

<p>But in case of a random unsorted array, the prediction will need to discard the partially executed instructions and start over with the correct branch most of the time and result in more CPU cycles compared to the sorted array.</p>
