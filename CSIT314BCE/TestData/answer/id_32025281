<p>The author of <em><a href="http://javascript.info/tutorial/closures" rel="noreferrer">Closures</a></em> has explained closures pretty well, explaining the reason why we need them and also explaining LexicalEnvironment which is necessary to understanding closures. <br/>
Here is the summary:</p>

<p>What if a variable is accessed, but it isn’t local? Like here:</p>

<p><a href="https://i.stack.imgur.com/SLlVB.png" rel="noreferrer"><img src="https://i.stack.imgur.com/SLlVB.png" alt="Enter image description here"></a></p>

<p>In this case, the interpreter finds the variable in the
outer <a href="http://javascript.info/tutorial/initialization" rel="noreferrer"><code>LexicalEnvironment</code></a> object.</p>

<p>The process consists of two steps:</p>

<ol>
<li>First, when a function f is created, it is not created in an empty
space. There is a current LexicalEnvironment object. In the case
above, it’s window (a is undefined at the time of function
creation).</li>
</ol>

<p><a href="https://i.stack.imgur.com/0KBin.png" rel="noreferrer"><img src="https://i.stack.imgur.com/0KBin.png" alt="Enter image description here"></a></p>

<p>When a function is created, it gets a hidden property, named [[Scope]], which references the current LexicalEnvironment.</p>

<p><a href="https://i.stack.imgur.com/U3yt7.png" rel="noreferrer"><img src="https://i.stack.imgur.com/U3yt7.png" alt="Enter image description here"></a></p>

<p>If a variable is read, but can not be found anywhere, an error is generated.</p>

<p><strong>Nested functions</strong></p>

<p>Functions can be nested one inside another, forming a chain of LexicalEnvironments which can also be called a scope chain.</p>

<p><a href="https://i.stack.imgur.com/2hUwr.png" rel="noreferrer"><img src="https://i.stack.imgur.com/2hUwr.png" alt="Enter image description here"></a></p>

<p>So, function g has access to g, a and f.</p>

<p><strong>Closures</strong></p>

<p>A nested function may continue to live after the outer function has finished:</p>

<p><a href="https://i.stack.imgur.com/S1mlB.png" rel="noreferrer"><img src="https://i.stack.imgur.com/S1mlB.png" alt="Enter image description here"></a></p>

<p>Marking up LexicalEnvironments:</p>

<p><a href="https://i.stack.imgur.com/BzUNi.png" rel="noreferrer"><img src="https://i.stack.imgur.com/BzUNi.png" alt="Enter image description here"></a></p>

<p>As we see, <code>this.say</code> is a property in the user object, so it continues to live after User completed.</p>

<p>And if you remember, when <code>this.say</code> is created, it (as every function) gets an internal reference <code>this.say.[[Scope]]</code> to the current LexicalEnvironment. So, the LexicalEnvironment of the current User execution stays in memory. All variables of User also are its properties, so they are also carefully kept, not junked as usually.</p>

<p><strong>The whole point is to ensure that if the inner function wants to access an outer variable in the future, it is able to do so.</strong></p>

<p>To summarize:</p>

<ol>
<li>The inner function keeps a reference to the outer
LexicalEnvironment.</li>
<li>The inner function may access variables from it
any time even if the outer function is finished.</li>
<li>The browser keeps the LexicalEnvironment and all its properties (variables) in memory until there is an inner function which references it.</li>
</ol>

<p>This is called a closure.</p>
