<p>First let's understand Memory allocation in Java:
Stack and Heap are part of Memory that JVM allocates for different purposes. The stack memory is pre-allocated to thread, when it is created, therefore, a thread cannot access the Stack of other thread. But Heap is available to all threads in a program.</p>

<p>For a thread, Stack stores all local data, metadata of program, primitive type data and object reference. And, Heap is responsible for storage of actual object.</p>

<pre><code>Book book = new Book("Effective Java");
</code></pre>

<p>In the above example, the reference variable is "book" which is stored in stack. The instance created by new operator -> new Book("Effective Java") is stored in Heap. The ref variable "book" has address of the object allocated in Heap. Let's say the address is 1001.</p>

<p><a href="https://i.stack.imgur.com/uw7tE.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/uw7tE.png" alt="enter image description here"></a></p>

<p>Consider passing a primitive data type i.e. int, float, double etc.</p>

<pre><code>public class PrimitiveTypeExample { 
    public static void main(string[] args) {
       int num = 10;
       System.out.println("Value before calling method: " + num);
       printNum(num);
       System.out.println("Value after calling method: " + num);
    }
    public static void printNum(int num){
       num = num + 10;
       System.out.println("Value inside printNum method: " + num);
    }
}
</code></pre>

<p>Output is:
Value before calling method: 10
Value inside printNum method: 20
Value after calling method: 10</p>

<p>int num =10; -> this allocates the memory for "int" in Stack of the running thread, because, it is a primitive type.  Now when printNum(..) is called, a private stack is created within the same thread. When "num" is passed to this method, a copy of "num" is created in the method stack frame.
num = num+10; -> this adds 10 and modifies the the int variable within the method stack frame.
Therefore, the original num outside the method stack frame remains unchanged.</p>

<p>Consider, the example of passing the object of a custom class as an argument.</p>

<p><a href="https://i.stack.imgur.com/J1XRW.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/J1XRW.png" alt="enter image description here"></a></p>

<p>In the above example, ref variable "book" resides in stack of thread executing the program, and the object of class Book is created in Heap space when program executes new Book(). This memory location in Heap is referred by "book". When "book" is passed as method argument, a copy  of "book" is created in  private stack frame of method within the same stack of thread. Therefore, the copied reference variable points to the same object of class "Book" in the Heap.</p>

<p><a href="https://i.stack.imgur.com/ggqd5.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/ggqd5.png" alt="enter image description here"></a></p>

<p>The reference variable within method stack frame sets a new value to same object. Therefore, it is reflected when original ref variable "book" gets its value.
Note that in case of passing reference variable, if it is initialized again in called method, it then points to new memory location and any operation does not affect the previous object in the Heap.</p>

<p>Therefore, when anything is passed as method argument, it is always the Stack entity - either primitive or reference variable. We never pass something that is stored in Heap. Hence, in Java, we always pass the value in the stack, and it is pass by value.</p>
