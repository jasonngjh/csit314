<p>Others have directly answered your question, but when trying to understand the stack and the heap, I think it is helpful to consider the memory layout of a traditional UNIX process (without threads and <code>mmap()</code>-based allocators). The <a href="http://www.memorymanagement.org/glossary/b.html#term-brk" rel="noreferrer">Memory Management Glossary</a> web page has a diagram of this memory layout.</p>

<p>The stack and heap are traditionally located at opposite ends of the process's virtual address space. The stack grows automatically when accessed, up to a size set by the kernel (which can be adjusted with <code>setrlimit(RLIMIT_STACK, ...)</code>). The heap grows when the memory allocator invokes the <code>brk()</code> or <code>sbrk()</code> system call, mapping more pages of physical memory into the process's virtual address space. </p>

<p>In systems without virtual memory, such as some embedded systems, the same basic layout often applies, except the stack and heap are fixed in size. However, in other embedded systems (such as those based on Microchip PIC microcontrollers), the program stack is a separate block of memory that is not addressable by data movement instructions, and can only be modified or read indirectly through program flow instructions (call, return, etc.). Other architectures, such as Intel Itanium processors, have <a href="http://blogs.msdn.com/oldnewthing/archive/2005/04/21/410397.aspx" rel="noreferrer">multiple stacks</a>. In this sense, the stack is an element of the CPU architecture.</p>
