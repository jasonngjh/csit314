<p>Here is an example in plain language. I will provide a correspondence between high-level human concepts to low-level Python concepts.</p>

<p>I want to operate on a sequence of numbers, but I don't want to bother my self with the creation of that sequence, I want only to focus on the operation I want to do. So, I do the following:</p>

<ul>
<li>I call you and tell you that I want a sequence of numbers which is produced in a specific way, and I let you know what the algorithm is. <br/>
<b>This step corresponds to <code>def</code>ining the generator function, i.e. the function containing a <code>yield</code>.</b></li>
<li>Sometime later, I tell you, "OK, get ready to tell me the sequence of numbers". <br/>
<b>This step corresponds to calling the generator function which returns a generator object.</b> Note that you don't tell me any numbers yet; you just grab your paper and pencil.</li>
<li>I ask you, "tell me the next number", and you tell me the first number; after that, you wait for me to ask you for the next number. It's your job to remember where you were, what numbers you have already said, and what is the next number. I don't care about the details. <br/>
<b>This step corresponds to calling <code>.next()</code> on the generator object.</b></li>
<li>… repeat previous step, until…</li>
<li>eventually, you might come to an end. You don't tell me a number; you just shout, "hold your horses! I'm done! No more numbers!" <br/>
<b>This step corresponds to the generator object ending its job, and raising a <code>StopIteration</code> exception</b> The generator function does not need to raise the exception. It's raised automatically when the function ends or issues a <code>return</code>.</li>
</ul>

<p>This is what a generator does (a function that contains a <code>yield</code>); it starts executing, pauses whenever it does a <code>yield</code>, and when asked for a <code>.next()</code> value it continues from the point it was last. It fits perfectly by design with the iterator protocol of Python, which describes how to sequentially request values.</p>

<p>The most famous user of the iterator protocol is the <code>for</code> command in Python. So, whenever you do a:</p>

<pre><code>for item in sequence:
</code></pre>

<p>it doesn't matter if <code>sequence</code> is a list, a string, a dictionary or a generator <em>object</em> like described above; the result is the same: you read items off a sequence one by one.</p>

<p>Note that <code>def</code>ining a function which contains a <code>yield</code> keyword is not the only way to create a generator; it's just the easiest way to create one.</p>

<p>For more accurate information, read about <a href="http://docs.python.org/library/stdtypes.html#iterator-types" rel="noreferrer">iterator types</a>, the <a href="http://docs.python.org/reference/simple_stmts.html#yield" rel="noreferrer">yield statement</a> and <a href="http://docs.python.org/glossary.html#term-generator" rel="noreferrer">generators</a> in the Python documentation.</p>
