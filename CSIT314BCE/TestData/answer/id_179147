<h1>Amending the most recent commit message</h1>

<pre class="lang-sh prettyprint-override"><code>git commit --amend
</code></pre>

<p>will open your editor, allowing you to change the commit message of the most recent commit. Additionally, you can set the commit message directly in the command line with:</p>

<pre class="lang-sh prettyprint-override"><code>git commit --amend -m "New commit message"
</code></pre>

<p>â€¦however, this can make multi-line commit messages or small corrections more cumbersome to enter.</p>

<p>Make sure you don't have any working copy changes <em>staged</em> before doing this or they will get committed too. (<em>Unstaged</em> changes will not get committed.)</p>

<h2>Changing the message of a commit that you've already pushed to your remote branch</h2>

<p>If you've already pushed your commit up to your remote branch, then - after amending your commit locally (as described above) - you'll also <a href="https://stackoverflow.com/questions/41003071/why-must-i-force-push-after-changing-a-commit-message">need to force push the commit</a> with:</p>

<pre class="lang-bash prettyprint-override"><code>git push &lt;remote&gt; &lt;branch&gt; --force
# Or
git push &lt;remote&gt; &lt;branch&gt; -f
</code></pre>

<p><strong>Warning: force-pushing will overwrite the remote branch with the state of your local one</strong>. If there are commits on the remote branch that you don't have in your local branch, you <em>will</em> lose those commits.</p>

<p><strong>Warning: be cautious about amending commits that you have already shared with other people.</strong> Amending commits essentially <em>rewrites</em> them to have different <a href="http://en.wikipedia.org/wiki/SHA-1" rel="noreferrer">SHA</a> IDs, which poses a problem if other people have copies of the old commit that you've rewritten. Anyone who has a copy of the old commit will need to synchronize their work with your newly re-written commit, which can sometimes be difficult, so make sure you coordinate with others when attempting to rewrite shared commit history, or just avoid rewriting shared commits altogether.</p>

<hr>

<h3>Perform an interactive rebase</h3>

<p>Another option is to use interactive rebase.
This allows you to edit any message you want to update even if it's not the latest message.</p>

<p>In order to do a Git squash, follow these steps:</p>

<pre><code>// n is the number of commits up to the last commit you want to be able to edit
git rebase -i HEAD~n
</code></pre>

<p>Once you squash your commits - choose the <code>e/r</code> for editing the message:</p>

<p><a href="https://i.stack.imgur.com/LVcm9.png" rel="noreferrer"><img src="https://i.stack.imgur.com/LVcm9.png" alt="Enter image description here"></a></p>

<h3>Important note about interactive rebase</h3>

<p>When you use <code>git rebase -i HEAD~n</code> there can be <strong>more</strong> than n commits. Git will "collect" all the commits in the last n commits, and if there was a merge somewhere in between that range you will see all the commits as well, so the outcome will be n + .</p>

<h3>Good tip:</h3>

<p>If you have to do it for more than a single branch and you might face conflicts when amending the content, set up <a href="https://stackoverflow.com/questions/35415925/is-it-possible-to-setup-git-merge-for-automatic-resolving-git-rerere/35417944#35417944"><code>git rerere</code></a> and let Git resolve those conflicts automatically for you.</p>

<hr>

<h2>Documentation</h2>

<ul>
<li><p><a href="https://www.kernel.org/pub/software/scm/git/docs/git-commit.html" rel="noreferrer">git-commit(1) Manual Page</a></p></li>
<li><p><a href="https://www.kernel.org/pub/software/scm/git/docs/git-rebase.html" rel="noreferrer">git-rebase(1) Manual Page</a></p></li>
<li><p><a href="https://www.kernel.org/pub/software/scm/git/docs/git-push.html" rel="noreferrer">git-push(1) Manual Page</a></p></li>
</ul>
