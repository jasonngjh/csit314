<p>From a programming viewpoint, the iterators are implemented as <a href="http://en.wikipedia.org/wiki/Thunk_(functional_programming)" rel="noreferrer">thunks</a>.</p>

<p>To implement iterators, generators, and thread pools for concurrent execution, etc. as thunks (also called anonymous functions), one uses messages sent to a closure object, which has a dispatcher, and the dispatcher answers to "messages".</p>

<p><a href="http://en.wikipedia.org/wiki/Message_passing" rel="noreferrer">http://en.wikipedia.org/wiki/Message_passing</a></p>

<p>"<em>next</em>" is a message sent to a closure, created by the "<em>iter</em>" call.</p>

<p>There are lots of ways to implement this computation. I used mutation, but it is easy to do it without mutation, by returning the current value and the next yielder.</p>

<p>Here is a demonstration which uses the structure of R6RS, but the semantics is absolutely identical to Python's. It's the same model of computation, and only a change in syntax is required to rewrite it in Python.</p>

<blockquote>
<pre><code>Welcome to Racket v6.5.0.3.

-&gt; (define gen
     (lambda (l)
       (define yield
         (lambda ()
           (if (null? l)
               'END
               (let ((v (car l)))
                 (set! l (cdr l))
                 v))))
       (lambda(m)
         (case m
           ('yield (yield))
           ('init  (lambda (data)
                     (set! l data)
                     'OK))))))
-&gt; (define stream (gen '(1 2 3)))
-&gt; (stream 'yield)
1
-&gt; (stream 'yield)
2
-&gt; (stream 'yield)
3
-&gt; (stream 'yield)
'END
-&gt; ((stream 'init) '(a b))
'OK
-&gt; (stream 'yield)
'a
-&gt; (stream 'yield)
'b
-&gt; (stream 'yield)
'END
-&gt; (stream 'yield)
'END
-&gt;
</code></pre>
</blockquote>
