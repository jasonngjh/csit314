<p>C didn't initially have the <code>const</code> keyword, so it would break legacy code if they changed literals to require <code>const</code>-qualification after introduction of the keyword. C's string-literals are immutable, though, so changing the contents is undefined behavior even if it's not <code>const</code>-qualified.</p>

<p>C++, on the other hand, was designed with the <code>const</code> keyword.  Initially, C++ did allow for string literals to be assigned to non <code>const</code>-qualified <code>char *</code>s presumably for compatibility with existing C code.  As of the C++03 standard, however, they decided to deprecate this functionality rather than allowing the dissonance to continue into perpetuity.  I would guess the amount of legacy C++ code relying on non-<code>const</code> qualified <code>char *</code>s pointing to string literals to be small enough that it was a worthy trade-off.</p>
