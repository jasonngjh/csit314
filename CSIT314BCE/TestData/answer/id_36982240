<h2>In Short</h2>

<p>A stack is used for static memory allocation and a heap for dynamic memory allocation, both stored in the computer's RAM.</p>

<hr>

<h2>In Detail</h2>

<p><strong>The Stack</strong></p>

<p>The stack is a "LIFO" (last in, first out) data structure, that is managed and optimized by the CPU quite closely. Every time a function declares a new variable, it is "pushed" onto the stack. Then every time a function exits, all of the variables pushed onto the stack by that function, are freed (that is to say, they are deleted). Once a stack variable is freed, that region of memory becomes available for other stack variables.</p>

<p>The advantage of using the stack to store variables, is that memory is managed for you. You don't have to allocate memory by hand, or free it once you don't need it any more. What's more, because the CPU organizes stack memory so efficiently, reading from and writing to stack variables is very fast.</p>

<p>More can be found <strong><a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)" rel="noreferrer">here</a></strong>.</p>

<hr>

<p><strong>The Heap</strong></p>

<p>The heap is a region of your computer's memory that is not managed automatically for you, and is not as tightly managed by the CPU. It is a more free-floating region of memory (and is larger). To allocate memory on the heap, you must use malloc() or calloc(), which are built-in C functions. Once you have allocated memory on the heap, you are responsible for using free() to deallocate that memory once you don't need it any more.</p>

<p>If you fail to do this, your program will have what is known as a memory leak. That is, memory on the heap will still be set aside (and won't be available to other processes). As we will see in the debugging section, there is a tool called <a href="http://en.wikipedia.org/wiki/Valgrind" rel="noreferrer">Valgrind</a> that can help you detect memory leaks.</p>

<p>Unlike the stack, the heap does not have size restrictions on variable size (apart from the obvious physical limitations of your computer). Heap memory is slightly slower to be read from and written to, because one has to use pointers to access memory on the heap. We will talk about pointers shortly.</p>

<p>Unlike the stack, variables created on the heap are accessible by any function, anywhere in your program. Heap variables are essentially global in scope.</p>

<p>More can be found <strong><a href="https://en.wikipedia.org/wiki/Memory_management" rel="noreferrer">here</a></strong>.</p>

<hr>

<p>Variables allocated on the stack are stored directly to the memory and access to this memory is very fast, and its allocation is dealt with when the program is compiled. When a function or a method calls another function which in turns calls another function, etc., the execution of all those functions remains suspended until the very last function returns its value. The stack is always reserved in a LIFO order, the most recently reserved block is always the next block to be freed. This makes it really simple to keep track of the stack, freeing a block from the stack is nothing more than adjusting one pointer.</p>

<p>Variables allocated on the heap have their memory allocated at run time and accessing this memory is a bit slower, but the heap size is only limited by the size of virtual memory. Elements of the heap have no dependencies with each other and can always be accessed randomly at any time. You can allocate a block at any time and free it at any time. This makes it much more complex to keep track of which parts of the heap are allocated or free at any given time.</p>

<p><a href="https://i.stack.imgur.com/KdBPf.png" rel="noreferrer"><img src="https://i.stack.imgur.com/KdBPf.png" alt="Enter image description here"></a></p>

<p>You can use the stack if you know exactly how much data you need to allocate before compile time, and it is not too big. You can use the heap if you don't know exactly how much data you will need at runtime or if you need to allocate a lot of data.</p>

<p>In a multi-threaded situation each thread will have its own completely independent stack, but they will share the heap. The stack is thread specific and the heap is application specific. The stack is important to consider in exception handling and thread executions.</p>

<p>Each thread gets a stack, while there's typically only one heap for the application (although it isn't uncommon to have multiple heaps for different types of allocation).</p>

<p><a href="https://i.stack.imgur.com/J0teH.gif" rel="noreferrer"><img src="https://i.stack.imgur.com/J0teH.gif" alt="Enter image description here"></a></p>

<p>At run-time, if the application needs more heap, it can allocate memory from free memory and if the stack needs memory, it can allocate memory from free memory allocated memory for the application.</p>

<p>Even, more detail is given <a href="http://net-informations.com/faq/net/stack-heap.htm" rel="noreferrer"><strong>here</strong></a> and <a href="http://gribblelab.org/CBootcamp/7_Memory_Stack_vs_Heap.html" rel="noreferrer"><strong>here</strong></a>.</p>

<hr>

<p>Now come to <strong>your question's answers</strong>.</p>

<blockquote>
  <p><strong>To what extent are they controlled by the OS or language runtime?</strong></p>
</blockquote>

<p>The OS allocates the stack for each system-level thread when the thread is created. Typically the OS is called by the language runtime to allocate the heap for the application.</p>

<p>More can be found <strong><a href="https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap/80113#80113">here</a></strong>.</p>

<blockquote>
  <p><strong>What is their scope?</strong></p>
</blockquote>

<p>Already given in top.</p>

<blockquote>
  <p>"You can use the stack if you know exactly how much data you need to allocate before compile time, and it is not too big. You can use the heap if you don't know exactly how much data you will need at runtime or if you need to allocate a lot of data."</p>
</blockquote>

<p>More can be found in <a href="https://stackoverflow.com/questions/408670/stack-static-and-heap-in-c">here</a>.</p>

<blockquote>
  <p><strong>What determines the size of each of them?</strong></p>
</blockquote>

<p>The size of the stack is set by <a href="https://en.wikipedia.org/wiki/Operating_system" rel="noreferrer">OS</a> when a thread is created. The size of the heap is set on application startup, but it can grow as space is needed (the allocator requests more memory from the operating system).</p>

<blockquote>
  <p><strong>What makes one faster?</strong></p>
</blockquote>

<p>Stack allocation is much faster since all it really does is move the stack pointer. Using memory pools, you can get comparable performance out of heap allocation, but that comes with a slight added complexity and its own headaches.</p>

<p>Also, stack vs. heap is not only a performance consideration; it also tells you a lot about the expected lifetime of objects.</p>

<p>Details can be found from <strong><a href="https://stackoverflow.com/questions/161053/which-is-faster-stack-allocation-or-heap-allocation">here</a></strong>.</p>
