<h2>Important: If you have any local changes, they will be lost. With or without <code>--hard</code> option, any local commits that haven't been pushed will be lost.<sup>[*]</sup></h2>

<p>If you have any files that are <em>not</em> tracked by Git (e.g. uploaded user content), these files will not be affected.</p>

<hr>

<p>I think this is the right way:</p>

<pre><code>git fetch --all
</code></pre>

<p>Then, you have two options:</p>

<pre><code>git reset --hard origin/master
</code></pre>

<p>OR If you are on some other branch:</p>

<pre><code>git reset --hard origin/&lt;branch_name&gt;
</code></pre>

<h3>Explanation:</h3>

<p><code>git fetch</code> downloads the latest from remote without trying to merge or rebase anything.</p>

<p>Then the <code>git reset</code> resets the master branch to what you just fetched. The <code>--hard</code> option changes all the files in your working tree to match the files in <code>origin/master</code></p>

<hr>

<h3>Maintain current local commits</h3>

<p><sup>[*]</sup>: It's worth noting that it is possible to maintain current local commits by creating a branch from <code>master</code> before resetting:</p>

<pre><code>git checkout master
git branch new-branch-to-save-current-commits
git fetch --all
git reset --hard origin/master
</code></pre>

<p>After this, all of the old commits will be kept in <code>new-branch-to-save-current-commits</code>. </p>

<h3>Uncommitted changes</h3>

<p>Uncommitted changes, however (even staged), will be lost. Make sure to stash and commit anything you need. For that you can run the following:</p>

<pre><code>git stash
</code></pre>

<p>And then to reapply these uncommitted changes:</p>

<pre><code>git stash pop
</code></pre>
