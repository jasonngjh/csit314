<p>All of the level functions you've defined have the type <code>a -&gt; a</code> (or <code>a -&gt; [a]</code>) with some constraints on <code>a</code> attached to them. So in all cases the type that comes out will be the type that went in (or a list thereof).</p>

<p>So when calling each of your <code>level</code> functions there are two possible outcomes: either the call is ill-typed because the type of the argument does not meet the constraints or you'll get back a value of the same time (or a list thereof). Either way it's impossible that you'd put in an <code>Int</code> and get back a <code>Float</code>.</p>

<p>So <code>sqrt (6*total)</code> was treated as an <code>Int</code> because, as we've just discussed, the type that comes out will be the same type that goes in and the type that came in was <code>Int</code>. Now the type that came in didn't actually meet the constraints, so you might expect an error about that. And without the type signature, you'd get exactly that error (once the function is called with an argument of type <code>Int</code>). But with the type signature, the error about the return type not matching is detected before the constraints are checked, so that's why you get that error.</p>
