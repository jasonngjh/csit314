<p>Here is a mental image of what <code>yield</code> does.</p>

<p>I like to think of a thread as having a stack (even when it's not implemented that way).</p>

<p>When a normal function is called, it puts its local variables on the stack, does some computation, then clears the stack and returns. The values of its local variables are never seen again.</p>

<p>With a <code>yield</code> function, when its code begins to run (i.e. after the function is called, returning a generator object, whose <code>next()</code> method is then invoked), it similarly puts its local variables onto the stack and computes for a while. But then, when it hits the <code>yield</code> statement, before clearing its part of the stack and returning, it takes a snapshot of its local variables and stores them in the generator object. It also writes down the place where it's currently up to in its code (i.e. the particular <code>yield</code> statement).</p>

<p>So it's a kind of a frozen function that the generator is hanging onto.</p>

<p>When <code>next()</code> is called subsequently, it retrieves the function's belongings onto the stack and re-animates it. The function continues to compute from where it left off, oblivious to the fact that it had just spent an eternity in cold storage.</p>

<p>Compare the following examples:</p>

<pre><code>def normalFunction():
    return
    if False:
        pass

def yielderFunction():
    return
    if False:
        yield 12
</code></pre>

<p>When we call the second function, it behaves very differently to the first. The <code>yield</code> statement might be unreachable, but if it's present anywhere, it changes the nature of what we're dealing with.</p>

<pre><code>&gt;&gt;&gt; yielderFunction()
&lt;generator object yielderFunction at 0x07742D28&gt;
</code></pre>

<p>Calling <code>yielderFunction()</code> doesn't run its code, but makes a generator out of the code. (Maybe it's a good idea to name such things with the <code>yielder</code> prefix for readability.)</p>

<pre><code>&gt;&gt;&gt; gen = yielderFunction()
&gt;&gt;&gt; dir(gen)
['__class__',
 ...
 '__iter__',    #Returns gen itself, to make it work uniformly with containers
 ...            #when given to a for loop. (Containers return an iterator instead.)
 'close',
 'gi_code',
 'gi_frame',
 'gi_running',
 'next',        #The method that runs the function's body.
 'send',
 'throw']
</code></pre>

<p>The <code>gi_code</code> and <code>gi_frame</code> fields are where the frozen state is stored. Exploring them with <code>dir(..)</code>, we can confirm that our mental model above is credible.</p>
