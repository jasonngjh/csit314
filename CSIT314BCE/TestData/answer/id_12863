<p>The best answer I have ever heard about using the provided type aliases in C# comes from Jeffrey Richter in his book <a href="https://rads.stackoverflow.com/amzn/click/com/0735621632" rel="noreferrer" rel="nofollow noreferrer">CLR Via C#</a>. Here are his 3 reasons:</p>

<blockquote>
  <ul>
  <li>I've seen a number of developers confused, not knowing whether to use <strong>string</strong> or <strong>String</strong> in their code. Because in C# the string (a keyword) maps exactly to System.String (an FCL type), there is no difference and either can be used.</li>
  <li>In C#, <strong>long</strong> maps to <strong>System.Int64</strong>, but in a different programming language, <strong>long</strong> could map to an <strong>Int16</strong> or <strong>Int32</strong>. In fact, C++/CLI does in fact treat long as an <strong>Int32</strong>. Someone reading source code in one language could easily misinterpret the code's intention if he or she were used to programming in a different programming language. In fact, most languages won't even treat <strong>long</strong> as a keyword and won't compile code that uses it.</li>
  <li>The FCL has many methods that have type names as part of their method names. For example, the <strong>BinaryReader</strong> type offers methods such as <strong>ReadBoolean</strong>, <strong>ReadInt32</strong>, <strong>ReadSingle</strong>, and so on, and the <strong>System.Convert</strong> type offers methods such as <strong>ToBoolean</strong>, <strong>ToInt32</strong>, <strong>ToSingle</strong>, and so on. Although it's legal to write the following code, the line with float feels very unnatural to me, and it's not obvious that the line is correct:</li>
  </ul>
</blockquote>

<pre><code>BinaryReader br = new BinaryReader(...);
float val  = br.ReadSingle(); // OK, but feels unnatural
Single val = br.ReadSingle(); // OK and feels good
</code></pre>

<p>So there you have it. I think these are all really good points. I however, don't find myself using Jeffrey's advice in my own code. Maybe I am too stuck in my C# world but I end up trying to make my code look like the framework code.</p>
