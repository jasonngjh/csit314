<p>Since some answers went nitpicking, I'm going to contribute my mite.</p>

<p>Surprisingly, no one has mentioned that multiple (i.e. not related to the number of running OS-level threads) call stacks are to be found not only in exotic languages (PostScript) or platforms (Intel Itanium), but also in <a href="http://en.wikipedia.org/wiki/Fiber_(computer_science)" rel="noreferrer"><em>fibers</em></a>, <a href="http://en.wikipedia.org/wiki/Green_threads" rel="noreferrer"><em>green threads</em></a> and some implementations of <a href="http://en.wikipedia.org/wiki/Coroutine" rel="noreferrer"><em>coroutines</em></a>.</p>

<p>Fibers, green threads and coroutines are in many ways similar, which leads to much confusion.  The difference between fibers and green threads is that the former use cooperative multitasking, while the latter may feature either cooperative or preemptive one (or even both). For the distinction between fibers and coroutines, see <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4024.pdf" rel="noreferrer">here</a>.</p>

<p>In any case, the purpose of both fibers, green threads and coroutines is having multiple functions executing concurrently, but <strong>not</strong> in parallel (see <a href="https://stackoverflow.com/questions/1050222/concurrency-vs-parallelism-what-is-the-difference">this SO question</a> for the distinction) within a single OS-level thread, transferring control back and forth from one another in an organized fashion.</p>

<p>When using fibers, green threads or coroutines, you <em>usually</em> have a separate stack per function. (Technically, not just a stack but a whole context of execution is per function. Most importantly, CPU registers.) For every thread there're as many stacks as there're concurrently running functions, and the thread is switching between executing each function according to the logic of your program. When a function runs to its end, its stack is destroyed. So, <strong>the number and lifetimes of stacks</strong> are dynamic and <strong>are not determined by the number of OS-level threads!</strong></p>

<p>Note that I said "<em>usually</em> have a separate stack per function". There're both <em>stackful</em> and <em>stackless</em> implementations of couroutines. Most notable stackful C++ implementations are <a href="http://www.boost.org/doc/libs/1_53_0/libs/coroutine/doc/html/index.html" rel="noreferrer">Boost.Coroutine</a> and <a href="https://msdn.microsoft.com/en-us/library/dd492418.aspx" rel="noreferrer">Microsoft PPL</a>'s <code>async/await</code>. (However, C++'s <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4134.pdf" rel="noreferrer">resumable functions</a> (a.k.a. "<code>async</code> and <code>await</code>"), which were proposed to C++17, are likely to use stackless coroutines.)</p>

<p>Fibers proposal to the C++ standard library is forthcoming. Also, there're some third-party <a href="https://stackoverflow.com/questions/1285714/lightweight-portable-c-fibers-mit-license">libraries</a>. Green threads are extremely popular in languages like Python and Ruby.</p>
