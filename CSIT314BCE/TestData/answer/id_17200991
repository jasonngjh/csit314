<p>I tend to learn better by GOOD/BAD comparisons. I like to see working code followed by non-working code that someone is likely to encounter. I put together <a href="http://jsfiddle.net/KMQZK/" rel="noreferrer">a jsFiddle</a> that does a comparison and tries to boil down the differences to the simplest explanations I could come up with.</p>

<h2>Closures done right:</h2>

<pre><code>console.log('CLOSURES DONE RIGHT');

var arr = [];

function createClosure(n) {
    return function () {
        return 'n = ' + n;
    }
}

for (var index = 0; index &lt; 10; index++) {
    arr[index] = createClosure(index);
}

for (var index in arr) {
    console.log(arr[index]());
}
</code></pre>

<ul>
<li><p>In the above code <code>createClosure(n)</code> is invoked in every iteration of the loop. Note that I named the variable <code>n</code> to highlight that it is a <strong>new</strong> variable created in a new function scope and is not the same variable as <code>index</code> which is bound to the outer scope.</p></li>
<li><p>This creates a new scope and <code>n</code> is bound to that scope; this means we have 10 separate scopes, one for each iteration.</p></li>
<li><p><code>createClosure(n)</code> returns a function that returns the n within that scope.</p></li>
<li><p>Within each scope <code>n</code> is bound to whatever value it had when <code>createClosure(n)</code> was invoked so the nested function that gets returned will always return the value of <code>n</code> that it had when <code>createClosure(n)</code> was invoked.</p></li>
</ul>

<h2>Closures done wrong:</h2>

<pre><code>console.log('CLOSURES DONE WRONG');

function createClosureArray() {
    var badArr = [];

    for (var index = 0; index &lt; 10; index++) {
        badArr[index] = function () {
            return 'n = ' + index;
        };
    }
    return badArr;
}

var badArr = createClosureArray();

for (var index in badArr) {
    console.log(badArr[index]());
}
</code></pre>

<ul>
<li><p>In the above code the loop was moved within the <code>createClosureArray()</code> function and the function now just returns the completed array, which at first glance seems more intuitive.</p></li>
<li><p>What might not be obvious is that since <code>createClosureArray()</code> is only invoked once only one scope is created for this function instead of one for every iteration of the loop.</p></li>
<li><p>Within this function a variable named <code>index</code> is defined. The loop runs and adds functions to the array that return <code>index</code>. Note that <code>index</code> is defined within the <code>createClosureArray</code> function which only ever gets invoked one time.</p></li>
<li><p>Because there was only one scope within the <code>createClosureArray()</code> function, <code>index</code> is only bound to a value within that scope. In other words, each time the loop changes the value of <code>index</code>, it changes it for everything that references it within that scope.</p></li>
<li><p>All of the functions added to the array return the SAME <code>index</code> variable from the parent scope where it was defined instead of 10 different ones from 10 different scopes like the first example. The end result is that all 10 functions return the same variable from the same scope.</p></li>
<li><p>After the loop finished and <code>index</code> was done being modified the end value was 10, therefore every function added to the array returns the value of the single <code>index</code> variable which is now set to 10.</p></li>
</ul>

<h2>Result</h2>

<blockquote>
  <p>CLOSURES DONE RIGHT<br>
  n = 0<br>
  n = 1<br>
  n = 2<br>
  n = 3<br>
  n = 4<br>
  n = 5<br>
  n = 6<br>
  n = 7<br>
  n = 8<br>
  n = 9  </p>
  
  <p>CLOSURES DONE WRONG<br>
  n = 10<br>
  n = 10<br>
  n = 10<br>
  n = 10<br>
  n = 10<br>
  n = 10<br>
  n = 10<br>
  n = 10<br>
  n = 10<br>
  n = 10  </p>
</blockquote>
