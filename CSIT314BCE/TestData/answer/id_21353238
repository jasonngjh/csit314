<p>The more I think about closure the more I see it as a 2-step process: <strong>init - action</strong></p>

<pre><code>init: pass first what's needed...
action: in order to achieve something for later execution.
</code></pre>

<p>To a 6-year old, I'd emphasize on the <em>practical aspect</em> of closure:</p>

<pre><code>Daddy: Listen. Could you bring mum some milk (2).
Tom: No problem.
Daddy: Take a look at the map that Daddy has just made: mum is there and daddy is here.
Daddy: But get ready first. And bring the map with you (1), it may come in handy
Daddy: Then off you go (3). Ok?
Tom: A piece of cake!
</code></pre>

<p><strong>Example</strong>: <em>Bring some milk to mum (=action). First get ready and bring the map (=init).</em></p>

<pre><code>function getReady(map) {
    var cleverBoy = 'I examine the ' + map;
    return function(what, who) {
        return 'I bring ' + what + ' to ' + who + 'because + ' cleverBoy; //I can access the map
    }
}
var offYouGo = getReady('daddy-map');
offYouGo('milk', 'mum');
</code></pre>

<p>Because if you bring with you a very important piece of information (the map), you're knowledgeable enough to execute other similar actions:</p>

<pre><code>offYouGo('potatoes', 'great mum');
</code></pre>

<p>To a developer I'd make a parallel between closures and <a href="http://en.wikipedia.org/wiki/Object-oriented_programming" rel="noreferrer">OOP</a>.
The <strong>init phase</strong> is similar to passing arguments to a constructor in a traditional OO language; the <strong>action phase</strong> is ultimately the method you call to achieve what you want. And the method has access these init arguments using a mechanism called <em>closure</em>.</p>

<p>See my another answer illustrating the parallelism between OO and closures:</p>

<p><em><a href="https://stackoverflow.com/questions/1595611/how-to-properly-create-a-custom-object-in-javascript/21352366#21352366">How to &quot;properly&quot; create a custom object in JavaScript?</a></em></p>
