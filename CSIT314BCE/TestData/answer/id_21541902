<p>While a lot of answers show why you'd use a <code>yield</code> to create a generator, there are more uses for <code>yield</code>.  It's quite easy to make a coroutine, which enables the passing of information between two blocks of code.  I won't repeat any of the fine examples that have already been given about using <code>yield</code> to create a generator.</p>

<p>To help understand what a <code>yield</code> does in the following code, you can use your finger to trace the cycle through any code that has a <code>yield</code>.  Every time your finger hits the <code>yield</code>, you have to wait for a <code>next</code> or a <code>send</code> to be entered.  When a <code>next</code> is called, you trace through the code until you hit the <code>yield</code>… the code on the right of the <code>yield</code> is evaluated and returned to the caller… then you wait.  When <code>next</code> is called again, you perform another loop through the code.  However, you'll note that in a coroutine, <code>yield</code> can also be used with a <code>send</code>… which will send a value from the caller <em>into</em> the yielding function. If a <code>send</code> is given, then <code>yield</code> receives the value sent, and spits it out the left hand side… then the trace through the code progresses until you hit the <code>yield</code> again (returning the value at the end, as if <code>next</code> was called).</p>

<p>For example:</p>

<pre><code>&gt;&gt;&gt; def coroutine():
...     i = -1
...     while True:
...         i += 1
...         val = (yield i)
...         print("Received %s" % val)
...
&gt;&gt;&gt; sequence = coroutine()
&gt;&gt;&gt; sequence.next()
0
&gt;&gt;&gt; sequence.next()
Received None
1
&gt;&gt;&gt; sequence.send('hello')
Received hello
2
&gt;&gt;&gt; sequence.close()
</code></pre>
