<p>This is a <strong>"can you"</strong> question. And here is a <strong>"yes"</strong> answer.</p>

<p>No, you shouldn't use duplicative object members to stuff side channel data into a JSON encoding. (See "The names within an object SHOULD be unique" <a href="https://tools.ietf.org/html/rfc7159">in the RFC</a>).</p>

<p>And yes, you could <a href="https://plus.google.com/+DouglasCrockfordEsq/posts/RK8qyGVaGSr">insert comments <em>around</em> the JSON</a>, which you could parse out.</p>

<p>But if you want a way of inserting and extracting arbitrary side-channel data to a valid JSON, here is an answer. We take advantage of the non-unique representation of data in a JSON encoding. This is allowed<sup>*</sup> in section two of the RFC under "whitespace is allowed before or after any of the six structural characters".</p>

<p><i><sup>*</sup>The RFC only states "whitespace is allowed before or after any of the six structural characters", not explicitly mentioning strings, numbers, "false", "true", and "null". This omission is ignored in ALL implementations.</i></p>

<hr>

<p>First, canonicalize your JSON by minifying it:</p>

<pre><code>$jsonMin = json_encode(json_decode($json));
</code></pre>

<p>Then encode your comment in binary:</p>

<pre><code>$hex = unpack('H*', $comment);
$commentBinary = base_convert($hex[1], 16, 2);
</code></pre>

<p>Then steg your binary:</p>

<pre><code>$steg = str_replace('0', ' ', $commentBinary);
$steg = str_replace('1', "\t", $steg);
</code></pre>

<p>Here is your output:</p>

<pre><code>$jsonWithComment = $steg . $jsonMin;
</code></pre>
