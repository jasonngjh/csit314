<p>From a personal <a href="http://tshikatshikaaa.blogspot.nl/2012/08/purpose-of-javascript-closure.html" rel="noreferrer">blog post</a>:</p>

<p>By default, JavaScript knows two types of scopes: global and local.</p>

<pre><code>var a = 1;

function b(x) {
    var c = 2;
    return x * c;
}
</code></pre>

<p>In the above code, variable a and function b are available from anywhere in the code (that is, globally). Variable <code>c</code> is only available within the <code>b</code> function scope (that is, local). Most software developers won't be happy with this lack of scope flexibility, especially in large programs.</p>

<p>JavaScript closures help solving that issue by tying a function with a context:</p>

<pre><code>function a(x) {
    return function b(y) {
        return x + y;
    }
}
</code></pre>

<p>Here, function <code>a</code> returns a function called <code>b</code>. Since <code>b</code> is defined within <code>a</code>, it automatically has access to whatever is defined in <code>a</code>, that is, <code>x</code> in this example. This is why <code>b</code> can return <code>x</code> + <code>y</code> without declaring <code>x</code>.</p>

<pre><code>var c = a(3);
</code></pre>

<p>Variable <code>c</code> is assigned the result of a call to a with parameter 3. That is, an instance of function <code>b</code> where <code>x</code> = 3. In other words, <code>c</code> is now a function equivalent to:</p>

<pre><code>var c = function b(y) {
    return 3 + y;
}
</code></pre>

<p>Function <code>b</code> remembers that <code>x</code> = 3 in its context. Therefore:</p>

<pre><code>var d = c(4);
</code></pre>

<p>will assign the value 3 + 4 to <code>d</code>, that is 7.</p>

<p><strong>Remark</strong>: If someone modifies the value of <code>x</code> (say <code>x</code> = 22) after the instance of function <code>b</code> has been created, this will be reflected in <code>b</code> too. Hence a later call to <code>c</code>(4) would return 22 + 4, that is 26.</p>

<p>Closures can also be used to limit the scope of variables and methods declared globally:</p>

<pre><code>(function () {
    var f = "Some message";
    alert(f);
})();
</code></pre>

<p>The above is a closure where the function has no name, no argument and is called immediately. The highlighted code, which declares a global variable <code>f</code>, limits the scopes of <code>f</code> to the closure.</p>

<p>Now, there is a common JavaScript caveat where closures can help:</p>

<pre><code>var a = new Array();

for (var i=0; i&lt;2; i++) {
    a[i]= function(x) { return x + i ; }
}
</code></pre>

<p>From the above, most would assume that array <code>a</code> would be initialized as follows:</p>

<pre><code>a[0] = function (x) { return x + 0 ; }
a[1] = function (x) { return x + 1 ; }
a[2] = function (x) { return x + 2 ; }
</code></pre>

<p>In reality, this is how a is initialized, since the last value of <code>i</code> in the context is 2:</p>

<pre><code>a[0] = function (x) { return x + 2 ; }
a[1] = function (x) { return x + 2 ; }
a[2] = function (x) { return x + 2 ; }
</code></pre>

<p>The solution is:</p>

<pre><code>var a = new Array();

for (var i=0; i&lt;2; i++) {
    a[i]= function(tmp) {
        return function (x) { return x + tmp ; }
    } (i);
}
</code></pre>

<p>The argument/variable <code>tmp</code> holds a local copy of the changing value of <code>i</code> when creating function instances.</p>
