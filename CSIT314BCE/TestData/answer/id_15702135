<p>Git has commands for every action imaginable, but it needs extensive knowledge to get things right and because of that it is counter-intuitive at best...</p>

<p><strong>What you did before:</strong></p>

<ul>
<li>Changed a file and used <code>git add .</code>, or <code>git add &lt;file&gt;</code>.</li>
</ul>

<p><strong>What you want:</strong></p>

<ul>
<li><p>Remove the file from the index, but keep it versioned and left with uncommitted changes in working copy:</p>

<pre><code>git reset head &lt;file&gt;
</code></pre></li>
<li><p>Reset the file to the last state from HEAD, undoing changes and removing them from the index:</p>

<pre class="lang-bash prettyprint-override"><code># Think `svn revert &lt;file&gt;` IIRC.
git reset HEAD &lt;file&gt;
git checkout &lt;file&gt;

# If you have a `&lt;branch&gt;` named like `&lt;file&gt;`, use:
git checkout -- &lt;file&gt;
</code></pre>

<p>This is needed since <code>git reset --hard HEAD</code> won't work with single files.</p></li>
<li><p>Remove <code>&lt;file&gt;</code> from index and versioning, keeping the un-versioned file with changes in working copy:</p>

<pre><code>git rm --cached &lt;file&gt;
</code></pre></li>
<li><p>Remove <code>&lt;file&gt;</code> from working copy and versioning completely:</p>

<pre><code>git rm &lt;file&gt;
</code></pre></li>
</ul>
