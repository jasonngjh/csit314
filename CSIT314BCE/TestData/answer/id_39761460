<p>There are lots of different takes here on the mechanics of the code in question, the "How", but for me none of it made sense until I understood the "Why". This should be especially helpful for new programmers.</p>

<p>Take file "ab.py":</p>

<pre><code>def a():
    print('A function in ab file');
a()
</code></pre>

<p>And a second file "xy.py":</p>

<pre><code>import ab
def main():
    print('main function: this is where the action is')
def x():
    print ('peripheral task: might be useful in other projects')
x()
if __name__ == "__main__":
    main()
</code></pre>

<blockquote>
  <p>What is this code actually doing?</p>
</blockquote>

<p>When you execute <code>xy.py</code>, you <code>import ab</code>. The import statement runs the module immediately on import, so <code>ab</code>'s operations get executed before the remainder of <code>xy</code>'s. Once finished with <code>ab</code>, it continues with <code>xy</code>.</p>

<p>The interpreter keeps track of which scripts are running with <code>__name__</code>. When you run a script - no matter what you've named it - the interpreter calls it <code>"__main__"</code>, making it the master or 'home' script that gets returned to after running an external script.</p>

<p>Any other script that's called from this <code>"__main__"</code> script is assigned its filename as its <code>__name__</code> (e.g., <code>__name__ == "ab.py"</code>). Hence, the line <code>if __name__ == "__main__":</code> is the interpreter's test to determine if it's interpreting/parsing the 'home' script that was initially executed, or if it's temporarily peeking into another (external) script. This gives the programmer flexibility to have the script behave differently if it's executed directly vs. called externally.</p>

<p>Let's step through the above code to understand what's happening, focusing first on the unindented lines and the order they appear in the scripts. Remember that function - or <code>def</code> - blocks don't do anything by themselves until they're called. What the interpreter might say if mumbled to itself:</p>

<ul>
<li>Open xy.py as the 'home' file; call it <code>"__main__"</code> in the <code>__name__</code> variable.</li>
<li>Import and open file with the <code>__name__ == "ab.py"</code>.</li>
<li>Oh, a function. I'll remember that.</li>
<li>Ok, function <code>a()</code>; I just learned that. Printing '<em>A function in ab file</em>'.</li>
<li>End of file; back to <code>"__main__"</code>!</li>
<li>Oh, a function. I'll remember that.</li>
<li>Another one.</li>
<li>Function <code>x()</code>; ok, printing '<em>peripheral task: might be useful in other projects</em>'.</li>
<li>What's this? An <code>if</code> statement. Well, the condition has been met (the variable <code>__name__</code> has been set to <code>"__main__"</code>), so I'll enter the <code>main()</code> function and print '<em>main function: this is where the action is</em>'.</li>
</ul>

<p>The bottom two lines mean: "If this is the <code>"__main__"</code> or 'home' script, execute the function called <code>main()</code>". That's why you'll see a <code>def main():</code> block up top, which contains the main flow of the script's functionality.</p>

<blockquote>
  <p>Why implement this?</p>
</blockquote>

<p>Remember what I said earlier about import statements? When you import a module it doesn't just 'recognize' it and wait for further instructions - it actually runs all the executable operations contained within the script. So, putting the meat of your script into the <code>main()</code> function effectively quarantines it, putting it in isolation so that it won't immediately run when imported by another script.</p>

<p>Again, there will be exceptions, but common practice is that <code>main()</code> doesn't usually get called externally. So you may be wondering one more thing: if we're not calling <code>main()</code>, why are we calling the script at all? It's because many people structure their scripts with standalone functions that are built to be run independent of the rest of the code in the file. They're then later called somewhere else in the body of the script. Which brings me to this:</p>

<blockquote>
  <p>But the code works without it</p>
</blockquote>

<p>Yes, that's right. These separate functions <strong>can</strong> be called from an in-line script that's not contained inside a <code>main()</code> function. If you're accustomed (as I am, in my early learning stages of programming) to building in-line scripts that do exactly what you need, and you'll try to figure it out again if you ever need that operation again ... well, you're not used to this kind of internal structure to your code, because it's more complicated to build and it's not as intuitive to read.</p>

<p>But that's a script that probably can't have its functions called externally, because if it did it would immediately start calculating and assigning variables. And chances are if you're trying to re-use a function, your new script is related closely enough to the old one that there will be conflicting variables.</p>

<p>In splitting out independent functions, you gain the ability to re-use your previous work by calling them into another script. For example, "example.py" might import "xy.py" and call <code>x()</code>, making use of the 'x' function from "xy.py". (Maybe it's capitalizing the third word of a given text string; creating a NumPy array from a list of numbers and squaring them; or detrending a 3D surface. The possibilities are limitless.)</p>

<p>(As an aside, <a href="https://stackoverflow.com/questions/23000075/purpose-of-if-name-main">this question</a> contains an answer by @kindall that finally helped me to understand - the why, not the how. Unfortunately it's been marked as a duplicate of <a href="https://stackoverflow.com/questions/419163/what-does-if-name-main-do">this one</a>, which I think is a mistake.)</p>
