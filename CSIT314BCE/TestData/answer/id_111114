<p><strong>TLDR</strong></p>

<p>A closure is a link between a function and its outer lexical (ie. as-written) environment, such that the identifiers (variables, parameters, function declarations etc) defined within that environment are visible from within the function, regardless of when or from where the function is invoked.</p>

<p><strong>Details</strong></p>

<p>In the terminology of the ECMAScript specification, a closure can be said to be implemented by the <a href="https://www.ecma-international.org/ecma-262/10.0/index.html#sec-functioninitialize" rel="noreferrer"><code>[[Environment]]</code></a> reference of every function-object, which points to the <a href="https://www.ecma-international.org/ecma-262/10.0/index.html#sec-lexical-environments" rel="noreferrer">lexical environment</a> within which the function is defined.</p>

<p>When a function is invoked via the internal <a href="https://www.ecma-international.org/ecma-262/10.0/index.html#sec-ecmascript-function-objects-call-thisargument-argumentslist" rel="noreferrer"><code>[[Call]]</code></a> method, the <a href="https://www.ecma-international.org/ecma-262/10.0/index.html#sec-functioninitialize" rel="noreferrer"><code>[[Environment]]</code></a> reference on the function-object is copied into the <em>outer environment reference</em> of the <a href="https://www.ecma-international.org/ecma-262/10.0/index.html#sec-environment-records" rel="noreferrer">environment record</a> of the newly-created <a href="https://www.ecma-international.org/ecma-262/10.0/index.html#sec-execution-contexts" rel="noreferrer">execution context</a> (stack frame).</p>

<p>In the following example, function <code>f</code> closes over the lexical environment of the global execution context:</p>

<pre><code>function f() {}
</code></pre>

<p>In the following example, function <code>h</code> closes over the lexical environment of function <code>g</code>, which, in turn, closes over the lexical environment of the global execution context.</p>

<pre><code>function g() {
    function h() {}
}
</code></pre>

<p>If an inner function is returned by an outer, then the outer lexical environment will persist after the outer function has returned. This is because the outer lexical environment needs to be available if the inner function is eventually invoked.</p>

<p>In the following example, function <code>j</code> closes over the lexical environment of function <code>i</code>, meaning that variable <code>x</code> is visible from inside function <code>j</code>, long after function <code>i</code> has completed execution:</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>function i() {
    var x = 'mochacchino'
    return function j() {
        console.log('Printing the value of x, from within function j: ', x)
    }
} 

const k = i()
setTimeout(k, 500) // invoke k (which is j) after 500ms</code></pre>
</div>
</div>
</p>

<p>In a closure, the variables in the outer lexical environment <em>themselves</em> are available, <em>not</em> copies.</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>function l() {
  var y = 'vanilla';

  return {
    setY: function(value) {
      y = value;
    },
    logY: function(value) {
      console.log('The value of y is: ', y);
    }
  }
}

const o = l()
o.logY() // The value of y is: vanilla
o.setY('chocolate')
o.logY() // The value of y is: chocolate</code></pre>
</div>
</div>
</p>

<p>The chain of lexical environments, linked between execution contexts via outer environment references, forms a <em>scope chain</em> and defines the identifiers visible from any given function.</p>

<p><strong>Please note that in an attempt to improve clarity and accuracy, this answer has been substantially changed from the original.</strong></p>
