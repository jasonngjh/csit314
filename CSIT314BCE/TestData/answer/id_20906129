<p>As explained by others, there's a time discontinuity there. There are two possible timezone offsets for <code>1927-12-31 23:54:08</code> at <code>Asia/Shanghai</code>, but only one offset for <code>1927-12-31 23:54:07</code>. So, depending on which offset is used, there's either a one second difference or a 5 minutes and 53 seconds difference.</p>

<p>This slight shift of offsets, instead of the usual one-hour daylight savings (summer time) we are used to, obscures the problem a bit.</p>

<p>Note that the 2013a update of the timezone database moved this discontinuity a few seconds earlier, but the effect would still be observable.</p>

<p>The new <code>java.time</code> package on Java 8 let use see this more clearly, and provide tools to handle it. Given:</p>

<pre><code>DateTimeFormatterBuilder dtfb = new DateTimeFormatterBuilder();
dtfb.append(DateTimeFormatter.ISO_LOCAL_DATE);
dtfb.appendLiteral(' ');
dtfb.append(DateTimeFormatter.ISO_LOCAL_TIME);
DateTimeFormatter dtf = dtfb.toFormatter();
ZoneId shanghai = ZoneId.of("Asia/Shanghai");

String str3 = "1927-12-31 23:54:07";  
String str4 = "1927-12-31 23:54:08";  

ZonedDateTime zdt3 = LocalDateTime.parse(str3, dtf).atZone(shanghai);
ZonedDateTime zdt4 = LocalDateTime.parse(str4, dtf).atZone(shanghai);

Duration durationAtEarlierOffset = Duration.between(zdt3.withEarlierOffsetAtOverlap(), zdt4.withEarlierOffsetAtOverlap());

Duration durationAtLaterOffset = Duration.between(zdt3.withLaterOffsetAtOverlap(), zdt4.withLaterOffsetAtOverlap());
</code></pre>

<p>Then <code>durationAtEarlierOffset</code> will be one second, while <code>durationAtLaterOffset</code> will be five minutes and 53 seconds.</p>

<p>Also, these two offsets are the same:</p>

<pre><code>// Both have offsets +08:05:52
ZoneOffset zo3Earlier = zdt3.withEarlierOffsetAtOverlap().getOffset();
ZoneOffset zo3Later = zdt3.withLaterOffsetAtOverlap().getOffset();
</code></pre>

<p>But these two are different:</p>

<pre><code>// +08:05:52
ZoneOffset zo4Earlier = zdt4.withEarlierOffsetAtOverlap().getOffset();

// +08:00
ZoneOffset zo4Later = zdt4.withLaterOffsetAtOverlap().getOffset();
</code></pre>

<p>You can see the same problem comparing <code>1927-12-31 23:59:59</code> with <code>1928-01-01 00:00:00</code>, though, in this case, it is the earlier offset that produces the longer divergence, and it is the earlier date that has two possible offsets.</p>

<p>Another way to approach this is to check whether there's a transition going on. We can do this like this:</p>

<pre><code>// Null
ZoneOffsetTransition zot3 = shanghai.getRules().getTransition(ld3.toLocalDateTime);

// An overlap transition
ZoneOffsetTransition zot4 = shanghai.getRules().getTransition(ld3.toLocalDateTime);
</code></pre>

<p>You can check whether the transition is an overlap where there's more than one valid offset for that date/time or a gap where that date/time is not valid for that zone id - by using the <code>isOverlap()</code> and <code>isGap()</code> methods on <code>zot4</code>.</p>

<p>I hope this helps people handle this sort of issue once Java 8 becomes widely available, or to those using Java 7 who adopt the JSR 310 backport.</p>
