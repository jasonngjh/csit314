<h1>There are four noteworthy comparisons between the two different declarations of functions as listed below.</h1>

<ol>
<li>Availability (scope) of the function</li>
</ol>

<p>The following works because <code>function add()</code> is scoped to the nearest block:</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>try {
  console.log("Success: ", add(1, 1));
} catch(e) {
  console.log("ERROR: " + e);
}

function add(a, b){
  return a + b;
}</code></pre>
</div>
</div>
</p>

<p>The following does not work because the variable is called before a function value is assigned to the variable <code>add</code>.</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>try {
  console.log("Success: ", add(1, 1));
} catch(e) {
  console.log("ERROR: " + e);
}

var add=function(a, b){
  return a + b;
}</code></pre>
</div>
</div>
</p>

<p>The above code is identical in functionality to the code below. Note that explicitly assigning <code>add = undefined</code> is superfluous because simply doing <code>var add;</code> is the exact same as <code>var add=undefined</code>.</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>var add = undefined;

try {
  console.log("Success: ", add(1, 1));
} catch(e) {
  console.log("ERROR: " + e);
}

add = function(a, b){
  return a + b;
}</code></pre>
</div>
</div>
</p>

<p>The following does not work because the <code>var add=</code> superseeds the <code>function add()</code>.</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>try {
  console.log("Success: ", add(1, 1));
} catch(e) {
  console.log("ERROR: " + e);
}

var add=function add(a, b){
  return a + b;
}</code></pre>
</div>
</div>
</p>

<ol start="2">
<li><em>(function)</em>.name</li>
</ol>

<p>The name of a function <code>function thefuncname(){}</code> is <em>thefuncname</em> when it is declared this way.</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>function foobar(a, b){}

console.log(foobar.name);</code></pre>
</div>
</div>
</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>var a = function foobar(){};

console.log(a.name);</code></pre>
</div>
</div>
</p>

<p>Otherwise, if a function is declared as <code>function(){}</code>, the <em>function</em>.name is the first variable used to store the function.</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>var a = function(){};
var b = (function(){ return function(){} });

console.log(a.name);
console.log(b.name);</code></pre>
</div>
</div>
</p>

<p>If there are no variables set to the function, then the functions name is the empty string (<code>""</code>).</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>console.log((function(){}).name === "");</code></pre>
</div>
</div>
</p>

<p>Lastly, while the variable the function is assigned to initially sets the name, successive variables set to the function do not change the name.</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>var a = function(){};
var b = a;
var c = b;

console.log(a.name);
console.log(b.name);
console.log(c.name);</code></pre>
</div>
</div>
</p>

<ol start="3">
<li>Performance</li>
</ol>

<p>In Google's V8 and Firefox's Spidermonkey there might be a few microsecond JIST compilation difference, but ultimately the result is the exact same. To prove this, let's examine the efficiency of JSPerf at microbenchmarks by comparing the speed of two blank code snippets. The <a href="https://jsperf.com/microbenchmark-analysis/1" rel="nofollow noreferrer">JSPerf tests are found here</a>. And, the <a href="http://jsben.ch/Ov6eJ" rel="nofollow noreferrer">jsben.ch testsare  found here</a>. As you can see, there is a noticable difference when there should be none. If you are really a performance freak like me, then it might be more worth your while trying to reduce the number of variables and functions in the scope and especially eliminating polymorphism (such as using the same variable to store two different types).</p>

<ol start="4">
<li>Variable Mutability</li>
</ol>

<p>When you use the <code>var</code> keyword to declare a variable, you can then reassign a different value to the variable like so.</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>(function(){
    "use strict";
    var foobar = function(){}; // initial value
    try {
        foobar = "Hello World!"; // new value
        console.log("[no error]");
    } catch(error) {
        console.log("ERROR: " + error.message);
    }
    console.log(foobar, window.foobar);
})();</code></pre>
</div>
</div>
</p>

<p>However, when we use the const-statement, the variable reference becomes immutable. This means that we cannot assign a new value to the variable. Please note, however, that this does not make the contents of the variable immutable: if you do <code>const arr = []</code>, then you can still do <code>arr[10] = "example"</code>. Only doing something like <code>arr = "new value"</code> or <code>arr = []</code> would throw an error as seen below.</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>(function(){
    "use strict";
    const foobar = function(){}; // initial value
    try {
        foobar = "Hello World!"; // new value
        console.log("[no error]");
    } catch(error) {
        console.log("ERROR: " + error.message);
    }
    console.log(foobar, window.foobar);
})();</code></pre>
</div>
</div>
</p>

<p>Interestingly, if we declare the variable as <code>function funcName(){}</code>, then the immutability of the variable is the same as declaring it with <code>var</code>.</p>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>(function(){
    "use strict";
    function foobar(){}; // initial value
    try {
        foobar = "Hello World!"; // new value
        console.log("[no error]");
    } catch(error) {
        console.log("ERROR: " + error.message);
    }
    console.log(foobar, window.foobar);
})();</code></pre>
</div>
</div>
</p>

<h2>What Is The "Nearest Block"</h2>

<p>The "nearest block" is the nearest "function," (including asynchronous functions, generator functions, and asynchronous generator functions). However, interestingly, a <code>function functionName() {}</code> behaves like a <code>var functionName = function() {}</code> when in a non-closure block to items outside said closure. Observe.</p>

<ul>
<li>Normal <code>var add=function(){}</code></li>
</ul>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>try {
  // typeof will simply return "undefined" if the variable does not exist
  if (typeof add !== "undefined") {
    add(1, 1); // just to prove it
    console.log("Not a block");
  }else if(add===undefined){ // this throws an exception if add doesn't exist
    console.log('Behaves like var add=function(a,b){return a+b}');
  }
} catch(e) {
  console.log("Is a block");
}
var add=function(a, b){return a + b}</code></pre>
</div>
</div>
</p>

<ul>
<li>Normal <code>function add(){}</code></li>
</ul>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>try {
  // typeof will simply return "undefined" if the variable does not exist
  if (typeof add !== "undefined") {
    add(1, 1); // just to prove it
    console.log("Not a block");
  }else if(add===undefined){ // this throws an exception if add doesn't exist
    console.log('Behaves like var add=function(a,b){return a+b}')
  }
} catch(e) {
  console.log("Is a block");
}
function add(a, b){
  return a + b;
}</code></pre>
</div>
</div>
</p>

<ul>
<li>Function</li>
</ul>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>try {
  // typeof will simply return "undefined" if the variable does not exist
  if (typeof add !== "undefined") {
    add(1, 1); // just to prove it
    console.log("Not a block");
  }else if(add===undefined){ // this throws an exception if add doesn't exist
    console.log('Behaves like var add=function(a,b){return a+b}')
  }
} catch(e) {
  console.log("Is a block");
}
(function () {
    function add(a, b){
      return a + b;
    }
})();</code></pre>
</div>
</div>
</p>

<ul>
<li>Statement (such as <code>if</code>, <code>else</code>, <code>for</code>, <code>while</code>, <code>try</code>/<code>catch</code>/<code>finally</code>, <code>switch</code>, <code>do</code>/<code>while</code>, <code>with</code>)</li>
</ul>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>try {
  // typeof will simply return "undefined" if the variable does not exist
  if (typeof add !== "undefined") {
    add(1, 1); // just to prove it
    console.log("Not a block");
  }else if(add===undefined){ // this throws an exception if add doesn't exist
    console.log('Behaves like var add=function(a,b){return a+b}')
  }
} catch(e) {
  console.log("Is a block");
}
{
    function add(a, b){
      return a + b;
    }
}</code></pre>
</div>
</div>
</p>

<ul>
<li>Arrow Function with <code>var add=function()</code></li>
</ul>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>try {
  // typeof will simply return "undefined" if the variable does not exist
  if (typeof add !== "undefined") {
    add(1, 1); // just to prove it
    console.log("Not a block");
  }else if(add===undefined){ // this throws an exception if add doesn't exist
    console.log('Behaves like var add=function(a,b){return a+b}')
  }
} catch(e) {
  console.log("Is a block");
}
(() =&gt; {
    var add=function(a, b){
      return a + b;
    }
})();</code></pre>
</div>
</div>
</p>

<ul>
<li>Arrow Function With <code>function add()</code></li>
</ul>

<p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>try {
  // typeof will simply return "undefined" if the variable does not exist
  if (typeof add !== "undefined") {
    add(1, 1); // just to prove it
    console.log("Not a block");
  }else if(add===undefined){ // this throws an exception if add doesn't exist
    console.log('Behaves like var add=function(a,b){return a+b}')
  }
} catch(e) {
  console.log("Is a block");
}
(() =&gt; {
    function add(a, b){
      return a + b;
    }
})();</code></pre>
</div>
</div>
</p>
