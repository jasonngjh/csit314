<p>You can never pass by reference in Java, and one of the ways that is obvious is when you want to return more than one value from a method call. Consider the following bit of code in C++:</p>

<pre><code>void getValues(int&amp; arg1, int&amp; arg2) {
    arg1 = 1;
    arg2 = 2;
}
void caller() {
    int x;
    int y;
    getValues(x, y);
    cout &lt;&lt; "Result: " &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; endl;
}
</code></pre>

<p>Sometimes you want to use the same pattern in Java, but you can't; at least not directly. Instead you could do something like this:</p>

<pre><code>void getValues(int[] arg1, int[] arg2) {
    arg1[0] = 1;
    arg2[0] = 2;
}
void caller() {
    int[] x = new int[1];
    int[] y = new int[1];
    getValues(x, y);
    System.out.println("Result: " + x[0] + " " + y[0]);
}
</code></pre>

<p>As was explained in previous answers, in Java you're passing a pointer to the array as a value into <code>getValues</code>. That is enough, because the method then modifies the array element, and by convention you're expecting element 0 to contain the return value. Obviously you can do this in other ways, such as structuring your code so this isn't necessary, or constructing a class that can contain the return value or allow it to be set. But the simple pattern available to you in C++ above is not available in Java.</p>
