<p><em><a href="https://stackoverflow.blog/2019/10/11/c-creator-bjarne-stroustrup-answers-our-top-five-c-questions/">Bjarne Stroustrup's Answer</a> to this question:</em></p>

<p>That sounds like an interview question. Is it true? How would you know? It is a bad idea to answer questions about efficiency without first doing some measurements, so it is important to know how to measure.</p>

<p>So, I tried with a vector of a million integers and got:</p>

<pre><code>Already sorted    32995 milliseconds
Shuffled          125944 milliseconds

Already sorted    18610 milliseconds
Shuffled          133304 milliseconds

Already sorted    17942 milliseconds
Shuffled          107858 milliseconds
</code></pre>

<p>I ran that a few times to be sure. Yes, the phenomenon is real. My key code was:</p>

<pre><code>void run(vector&lt;int&gt;&amp; v, const string&amp; label)
{
    auto t0 = system_clock::now();
    sort(v.begin(), v.end());
    auto t1 = system_clock::now();
    cout &lt;&lt; label 
         &lt;&lt; duration_cast&lt;microseconds&gt;(t1 — t0).count() 
         &lt;&lt; " milliseconds\n";
}

void tst()
{
    vector&lt;int&gt; v(1'000'000);
    iota(v.begin(), v.end(), 0);
    run(v, "already sorted ");
    std::shuffle(v.begin(), v.end(), std::mt19937{ std::random_device{}() });
    run(v, "shuffled    ");
}
</code></pre>

<p>At least the phenomenon is real with this compiler, standard library, and optimizer settings. Different implementations can and do give different answers. In fact, someone did do a more systematic study (a quick web search will find it) and most implementations show that effect.</p>

<p>One reason is branch prediction: the key operation in the sort algorithm is <code>“if(v[i] &lt; pivot]) …”</code> or equivalent. For a sorted sequence that test is always true whereas, for a random sequence, the branch chosen varies randomly.</p>

<p>Another reason is that when the vector is already sorted, we never need to move elements to their correct position. The effect of these little details is the factor of five or six that we saw.</p>

<p>Quicksort (and sorting in general) is a complex study that has attracted some of the greatest minds of computer science. A good sort function is a result of both choosing a good algorithm and paying attention to hardware performance in its implementation.</p>

<p>If you want to write efficient code, you need to know a bit about machine architecture.</p>
