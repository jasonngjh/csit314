<p><strong>Strict mode can prevent memory leaks.</strong></p>

<p>Please check the function below written in non-strict mode:</p>

<pre><code>function getname(){
    name = "Stack Overflow"; // Not using var keyword
    return name;
}
getname();
console.log(name); // Stack Overflow
</code></pre>

<p>In this function, we are using a variable called <code>name</code> inside the function. Internally, the compiler will first check if there is any variable declared with that particular name in that particular function scope. Since the compiler understood that there is no such variable, it will check in the outer scope. In our case, it is the global scope. Again, the compiler understood that there is also no variable declared in the global space with that name, so it creates such a variable for us in the global space. Conceptually, this variable will be created in the global scope and will be available in the entire application.</p>

<p>Another scenario is that, say, the variable is declared in a child function. In that case, the compiler checks the validity of that variable in the outer scope, i.e., the parent function. Only then it will check in the global space and create a variable for us there.
That means additional checks need to be done. This will affect the performance of the application.</p>

<hr>

<p>Now let's write the same function in strict mode.</p>

<pre><code>"use strict"
function getname(){
    name = "Stack Overflow"; // Not using var keyword
    return name;
}
getname();
console.log(name); 
</code></pre>

<p>We will get the following error.</p>

<pre><code>Uncaught ReferenceError: name is not defined
at getname (&lt;anonymous&gt;:3:15)
at &lt;anonymous&gt;:6:5
</code></pre>

<p>Here, the compiler throws the reference error. In strict mode, the compiler does not allow us to use the variable without declaring it. So memory leaks can be prevented. In addition, we can write more optimized code.</p>
