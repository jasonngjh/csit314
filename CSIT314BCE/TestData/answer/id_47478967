<p>What a shame you have an array of integers, not an object where the keys are string equivalents of these integers.</p>

<p>I've looked through a lot of these answers and they all seem to use "brute force" as far as I can see. I haven't examined every single one, apologies if this is not so. For a smallish array this is fine, but what if you have 000s of integers in it?</p>

<p>Correct me if I'm wrong, but can't we assume that in a <code>key =&gt; value</code> map, of the kind which a JavaScript object is, that the key retrieval mechanism can be assumed to be highly engineered and optimised? (NB: if some super-expert tells me that this is not the case, I can suggest using ECMAScript&nbsp;6's <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="nofollow noreferrer">Map class</a> instead, which certainly will be).</p>

<p>I'm just suggesting that, in certain circumstances, the best solution might be to convert your array to an object... the problem being, of course, that you might have repeating integer values.  I suggest putting those in buckets as the "value" part of the <code>key =&gt; value</code> entries. (NB: if you are sure you don't have any repeating array elements this can be much simpler: values "same as" keys, and just go <code>Object.values(...)</code> to get back your modified array).</p>

<p>So you could do:</p>

<pre><code>const arr = [ 1, 2, 55, 3, 2, 4, 55 ];
const f =    function( acc, val, currIndex ){
    // We have not seen this value before: make a bucket... NB: although val's typeof is 'number',
    // there is seamless equivalence between the object key (always string)
    // and this variable val.
    ! ( val in acc ) ? acc[ val ] = []: 0;
    // Drop another array index in the bucket
    acc[ val ].push( currIndex );
    return acc;
}
const myIntsMapObj = arr.reduce( f, {});

console.log( myIntsMapObj );
</code></pre>

<p>Output:</p>

<blockquote>
  <p>Object [ &lt;1 empty slot>, Array<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="nofollow noreferrer">1</a>, Array[2], Array<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="nofollow noreferrer">1</a>, Array<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="nofollow noreferrer">1</a>, &lt;5
  empty slots>, 46 moreâ€¦ ]</p>
</blockquote>

<p>It is then easy to delete all the numbers 55.</p>

<pre><code>delete myIntsMapObj[ 55 ]; // Again, although keys are strings this works
</code></pre>

<p>You don't have to delete them all: index values are pushed into their buckets in order of appearance, so (for example):</p>

<pre><code>myIntsMapObj[ 55 ].shift(); // And
myIntsMapObj[ 55 ].pop();
</code></pre>

<p>will delete the first and last occurrence respectively.  You can count frequency of occurrence easily, replace all 55s with 3s by transferring the contents of one bucket to another, etc.</p>

<p>Retrieving a modified <code>int</code> array from your "bucket object" is slightly involved but not so much: each bucket contains the index (in the original array) of the value represented by the (<code>string</code>) key. Each of these bucket values is also unique (each is the unique <em>index value</em> in the original array): so you turn them into keys in a new object, with the (real) integer from the "integer string key" as value... then sort the keys and go <code>Object.values( ... )</code>.</p>

<p>This sounds very involved and time-consuming... but obviously everything depends on the circumstances and desired usage. My understanding is that all versions and contexts of JavaScript operate only in one thread, and the thread doesn't "let go", so there could be some horrible congestion with a "brute force" method: caused not so much by the <code>indexOf</code> ops, but multiple repeated <code>slice</code>/<code>splice</code> ops.</p>

<p><strong>Addendum</strong> 
If you're <strong>sure</strong> this is too much engineering for your use case surely the simplest "brute force" approach is</p>

<pre><code>const arr = [ 1, 2, 3, 66, 8, 2, 3, 2 ];
const newArray = arr.filter( number =&gt; number !== 3 );
console.log( newArray )
</code></pre>

<p>(Yes, other answers have spotted <code>Array.prototype.filter</code>...)</p>
