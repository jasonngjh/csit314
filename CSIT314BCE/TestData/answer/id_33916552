<p>There are a number of variables that the system (Python interpreter) provides for source files (modules).  You can get their values anytime you want, so, let us focus on the <strong>__name__</strong> variable/attribute:</p>

<p>When Python loads a source code file, it executes all of the code found in it. (Note that it doesn't call all of the methods and functions defined in the file, but it does define them.)</p>

<p>Before the interpreter executes the source code file though, it defines a few special variables for that file; <strong>__name__</strong> is one of those special variables that Python automatically defines for each source code file.</p>

<p>If Python is loading this source code file as the main program (i.e. the file you run), then it sets the special <strong>__name__</strong> variable for this file to have a value <strong>"__main__"</strong>.</p>

<p>If this is being imported from another module, <strong>__name__</strong> will be set to that module's name.</p>

<p>So, in your example in part:</p>

<pre><code>if __name__ == "__main__":
   lock = thread.allocate_lock()
   thread.start_new_thread(myfunction, ("Thread #: 1", 2, lock))
   thread.start_new_thread(myfunction, ("Thread #: 2", 2, lock))
</code></pre>

<p>means that the code block:</p>

<pre><code>lock = thread.allocate_lock()
thread.start_new_thread(myfunction, ("Thread #: 1", 2, lock))
thread.start_new_thread(myfunction, ("Thread #: 2", 2, lock))
</code></pre>

<p>will be executed only when you run the module directly; the code block will not execute if another module is calling/importing it because the value of <strong>__name__</strong> will not equal to "<strong>main</strong>" in that particular instance.</p>

<p>Hope this helps out.</p>
